# HG changeset patch
# User William Stein <wstein@gmail.com>
# Date 1370129365 25200
# Node ID 0371489299c69a16b4442544febcfeca4f625b99
# Parent  1077314f416653b28e199c382667a1f11e444bdd
trac11975 part 1

diff --git a/module_list.py b/module_list.py
--- a/module_list.py
+++ b/module_list.py
@@ -12,23 +12,23 @@
 #########################################################
 
 ## Choose cblas library -- note -- make sure to update sage/misc/cython.py
-## if you change this!! 
+## if you change this!!
 if os.environ.has_key('SAGE_BLAS'):
     BLAS=os.environ['SAGE_BLAS']
     BLAS2=os.environ['SAGE_BLAS']
-elif os.path.exists('%s/lib/libatlas.so'%os.environ['SAGE_LOCAL']):   
+elif os.path.exists('%s/lib/libatlas.so'%os.environ['SAGE_LOCAL']):
     BLAS='cblas'
     BLAS2='atlas'
 elif os.path.exists('/usr/lib/libcblas.dylib') or \
      os.path.exists('/usr/lib/libcblas.so'):
     BLAS='cblas'
     BLAS2='atlas'
-elif os.path.exists('/usr/lib/libblas.dll.a'):   
+elif os.path.exists('/usr/lib/libblas.dll.a'):
     BLAS='gslcblas'
     BLAS2='gslcblas'
 else:
-    # This is very slow  (?), but *guaranteed* to be available. 
-    BLAS='gslcblas' 
+    # This is very slow  (?), but *guaranteed* to be available.
+    BLAS='gslcblas'
     BLAS2='gslcblas'
 
 
@@ -91,7 +91,7 @@
         return alternative
 
 ext_modules = [
-    
+
     ################################
     ##
     ## sage.algebras
@@ -132,11 +132,11 @@
                libraries = ["csage", "flint", "gmp", "gmpxx", "m", "stdc++", "ntl"]),
 
     ################################
-    ## 
+    ##
     ## sage.calculus
     ##
     ################################
-    
+
     Extension('sage.calculus.var',
               sources = ['sage/calculus/var.pyx']),
 
@@ -152,7 +152,7 @@
 
 
     ################################
-    ## 
+    ##
     ## sage.categories
     ##
     ################################
@@ -165,10 +165,10 @@
 
     Extension('sage.categories.functor',
               sources = ['sage/categories/functor.pyx']),
-              
+
     Extension('sage.categories.map',
               sources = ['sage/categories/map.pyx']),
-              
+
     Extension('sage.categories.morphism',
               sources = ['sage/categories/morphism.pyx']),
 
@@ -176,7 +176,7 @@
               sources = ['sage/categories/examples/semigroups_cython.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.coding
     ##
     ################################
@@ -185,7 +185,7 @@
               sources = ['sage/coding/binary_code.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.combinat
     ##
     ################################
@@ -193,7 +193,7 @@
     Extension('sage.combinat.expnums',
               sources = ['sage/combinat/expnums.pyx'],
               libraries = ['gmp']),
-                            
+
     Extension('sage.combinat.matrices.dancing_links',
               sources = ['sage/combinat/matrices/dancing_links.pyx'],
               libraries = ["stdc++"],
@@ -244,7 +244,7 @@
               sources = ['sage/combinat/q_bernoulli.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.crypto
     ##
     ################################
@@ -260,16 +260,16 @@
 
     Extension('sage.ext.c_lib',
               sources = ['sage/ext/c_lib.pyx']),
-    
+
     Extension('sage.ext.fast_callable',
               sources = ['sage/ext/fast_callable.pyx']),
-    
+
     Extension('sage.ext.fast_eval',
               sources = ['sage/ext/fast_eval.pyx']),
-    
+
     Extension('sage.ext.interactive_constructors_c',
               sources = ['sage/ext/interactive_constructors_c.pyx']),
-    
+
     Extension('sage.ext.multi_modular',
               sources = ['sage/ext/multi_modular.pyx'],
               extra_compile_args = ['-std=c99'],
@@ -287,7 +287,7 @@
     Extension('sage.finance.fractal',
               sources = ['sage/finance/fractal.pyx'],
               depends = numpy_depends),
-    
+
     Extension('sage.finance.markov_multifractal_cython',
               sources = ['sage/finance/markov_multifractal_cython.pyx']),
 
@@ -298,14 +298,14 @@
 
 
     ################################
-    ## 
-    ## sage.functions 
-    ## 
-    ################################ 
-    
-    Extension('sage.functions.prime_pi', 
-        sources = ['sage/functions/prime_pi.pyx']), 
-    
+    ##
+    ## sage.functions
+    ##
+    ################################
+
+    Extension('sage.functions.prime_pi',
+        sources = ['sage/functions/prime_pi.pyx']),
+
      ################################
      ##
      ## sage.games
@@ -334,7 +334,7 @@
      Extension('sage.geometry.triangulation.base',
                sources = ['sage/geometry/triangulation/functions.cc',
                           'sage/geometry/triangulation/data.cc',
-                          'sage/geometry/triangulation/base.pyx', 
+                          'sage/geometry/triangulation/base.pyx',
                           'sage/geometry/triangulation/triangulations.cc'],
                language="c++"),
 
@@ -460,7 +460,7 @@
         ################################
         ##
         ## sage.graphs.base
-        ## 
+        ##
         ################################
 
     Extension('sage.graphs.base.c_graph',
@@ -473,7 +473,7 @@
               sources = ['sage/graphs/base/dense_graph.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.groups
     ##
     ################################
@@ -493,9 +493,9 @@
         ###################################
         ##
         ## sage.groups.perm_gps.partn_ref
-        ## 
+        ##
         ###################################
-    
+
     Extension('sage.groups.perm_gps.partn_ref.automorphism_group_canonical_label',
               sources = ['sage/groups/perm_gps/partn_ref/automorphism_group_canonical_label.pyx'],
               libraries = ['gmp', 'flint'],
@@ -560,16 +560,16 @@
               depends = flint_depends),
 
     ################################
-    ## 
+    ##
     ## sage.gsl
     ##
     ################################
-    
+
     Extension('sage.gsl.callback',
               sources = ['sage/gsl/callback.pyx'],
               libraries = ['gsl', BLAS, BLAS2],
               define_macros=[('GSL_DISABLE_DEPRECATED','1')]),
-    
+
     Extension('sage.gsl.dwt',
               sources = ['sage/gsl/dwt.pyx'],
               libraries=['gsl',BLAS],
@@ -579,12 +579,12 @@
               sources = ['sage/gsl/fft.pyx'],
               libraries = ['gsl', BLAS, BLAS2],
               define_macros=[('GSL_DISABLE_DEPRECATED','1')]),
-    
+
     Extension('sage.gsl.gsl_array',
               sources = ['sage/gsl/gsl_array.pyx'],
               libraries=['gsl', BLAS, BLAS2],
               define_macros=[('GSL_DISABLE_DEPRECATED','1')]),
-    
+
     Extension('sage.gsl.integration',
               sources = ['sage/gsl/integration.pyx'],
               define_macros=[('GSL_DISABLE_DEPRECATED','1')],
@@ -592,21 +592,21 @@
 
     Extension('sage.gsl.interpolation',
               sources = ['sage/gsl/interpolation.pyx'],
-              libraries = ['gsl', BLAS, BLAS2], 
+              libraries = ['gsl', BLAS, BLAS2],
               define_macros=[('GSL_DISABLE_DEPRECATED','1')]),
-    
+
     Extension('sage.gsl.ode',
               sources = ['sage/gsl/ode.pyx'],
               libraries=['gsl',BLAS, BLAS2],
               define_macros=[('GSL_DISABLE_DEPRECATED','1')]),
-    
+
     Extension('sage.gsl.probability_distribution',
               sources = ['sage/gsl/probability_distribution.pyx'],
               libraries=['gsl', BLAS, BLAS2],
               define_macros=[('GSL_DISABLE_DEPRECATED','1')]),
 
     ################################
-    ## 
+    ##
     ## sage.interacts
     ##
     ################################
@@ -616,7 +616,7 @@
               libraries = []),
 
     ################################
-    ## 
+    ##
     ## sage.libs
     ##
     ################################
@@ -640,7 +640,7 @@
               include_dirs = [SAGE_INC + '/FLINT'],
               extra_compile_args=["-std=c99", "-D_XPG6"],
               depends = flint_depends),
-    
+
     Extension('sage.libs.fplll.fplll',
               sources = ['sage/libs/fplll/fplll.pyx'],
               libraries = ['gmp', 'mpfr', 'stdc++', 'fplll'],
@@ -665,16 +665,16 @@
               include_dirs = [SAGE_INC + "/libLfunction"],
               extra_compile_args=["-O3", "-ffast-math"],
               language = 'c++'),
-     
 
-    
+
+
     Extension('sage.libs.libecm',
               sources = ['sage/libs/libecm.pyx'],
               libraries = ['ecm', 'gmp'],
               extra_link_args = uname_specific("Linux", ["-Wl,-z,noexecstack"],
                                                         []),
               depends = [SAGE_INC + "/ecm.h"]),
-     
+
     Extension('sage.libs.mwrank.mwrank',
               sources = ["sage/libs/mwrank/mwrank.pyx",
                          "sage/libs/mwrank/wrap.cc"],
@@ -686,14 +686,14 @@
                         ],
               libraries = ["ec",
                            "ntl", "pari", "gmp", "gmpxx", "stdc++", "m"]),
-    
+
     Extension('sage.libs.pari.gen',
               sources = ["sage/libs/pari/gen.pyx"],
               libraries = ['pari', 'gmp']),
-    
+
     Extension('sage.libs.ppl',
               sources = ['sage/libs/ppl.pyx', 'sage/libs/ppl_shim.cc'],
-              libraries = ['ppl', 'gmpxx', 'gmp', 'm'], 
+              libraries = ['ppl', 'gmpxx', 'gmp', 'm'],
               language="c++",
               depends = [SAGE_INC + "/ppl.hh"]),
 
@@ -709,7 +709,7 @@
               include_dirs = [SAGE_INC + '/singular', SAGE_INC + '/factory'],
               depends = singular_depends,
               extra_compile_args = givaro_extra_compile_args),
-    
+
     Extension('sage.libs.singular.polynomial',
               sources = ['sage/libs/singular/polynomial.pyx'],
               libraries = singular_libs,
@@ -773,7 +773,7 @@
               libraries = ['gmp']),
 
         ################################
-        ## 
+        ##
         ## sage.libs.gap
         ##
         ################################
@@ -792,7 +792,7 @@
     #           sources = ["sage/libs/gap/type.pyx"],
     #           libraries = ['csage', 'gmp', 'gap', 'm'],
     #           include_dirs = [SAGE_INC]),
-    
+
     Extension('sage.libs.gap.libgap',
               sources = ["sage/libs/gap/libgap.pyx"],
               libraries = ['csage', 'gmp', 'gap', 'm'],
@@ -801,9 +801,9 @@
         ###################################
         ##
         ## sage.libs.cremona
-        ## 
+        ##
         ###################################
-        
+
     Extension('sage.libs.cremona.homspace',
               sources = ["sage/libs/cremona/homspace.pyx"],
               libraries = ['ec', 'ntl', 'pari',
@@ -841,9 +841,9 @@
         ###################################
         ##
         ## sage.libs.ntl
-        ## 
+        ##
         ###################################
-    
+
     # NOTE: It is *very* important (for cygwin) that csage be the
     # first library listed for all ntl extensions below.
 
@@ -943,14 +943,14 @@
               language='c++'),
 
     ################################
-    ## 
+    ##
     ## sage.matrix
     ##
     ################################
 
     Extension('sage.matrix.action',
               sources = ['sage/matrix/action.pyx']),
-    
+
     Extension('sage.matrix.change_ring',
               sources = ['sage/matrix/change_ring.pyx'],
               libraries=[BLAS, BLAS2, 'gmp'],
@@ -968,7 +968,7 @@
 
     Extension('sage.matrix.matrix2',
               sources = ['sage/matrix/matrix2.pyx']),
-    
+
     Extension('sage.matrix.matrix_complex_double_dense',
               sources = ['sage/matrix/matrix_complex_double_dense.pyx'],
               libraries=[BLAS, BLAS2],
@@ -982,16 +982,16 @@
 
     #Extension('sage.matrix.matrix_cyclo_sparse',
     #          sources = ['sage/matrix/matrix_cyclo_sparse.pyx']),
-    
+
     Extension('sage.matrix.matrix_dense',
               sources = ['sage/matrix/matrix_dense.pyx']),
-    
+
     #Extension('sage.matrix.matrix_domain_dense',
     #          sources = ['sage/matrix/matrix_domain_dense.pyx']),
 
     #Extension('sage.matrix.matrix_domain_sparse',
     #          sources = ['sage/matrix/matrix_domain_sparse.pyx']),
-              
+
     Extension('sage.matrix.matrix_double_dense',
               sources = ['sage/matrix/matrix_double_dense.pyx'],
               libraries=[BLAS, BLAS2],
@@ -1000,7 +1000,7 @@
 
     Extension('sage.matrix.matrix_generic_dense',
               sources = ['sage/matrix/matrix_generic_dense.pyx']),
-    
+
     Extension('sage.matrix.matrix_generic_sparse',
               sources = ['sage/matrix/matrix_generic_sparse.pyx']),
 
@@ -1064,18 +1064,18 @@
 
     #Extension('sage.matrix.matrix_pid_dense',
     #          sources = ['sage/matrix/matrix_pid_dense.pyx']),
-              
+
     #Extension('sage.matrix.matrix_pid_sparse',
     #          sources = ['sage/matrix/matrix_pid_sparse.pyx']),
 
     Extension('sage.matrix.matrix_rational_dense',
               sources = ['sage/matrix/matrix_rational_dense.pyx'],
               libraries = ['pari', 'gmp']),
-    
+
     Extension('sage.matrix.matrix_rational_sparse',
               sources = ['sage/matrix/matrix_rational_sparse.pyx'],
               libraries = ['gmp']),
-    
+
     Extension('sage.matrix.matrix_real_double_dense',
               sources = ['sage/matrix/matrix_real_double_dense.pyx'],
               libraries=[BLAS, BLAS2],
@@ -1084,7 +1084,7 @@
 
     Extension('sage.matrix.matrix_sparse',
               sources = ['sage/matrix/matrix_sparse.pyx']),
-    
+
     Extension('sage.matrix.matrix_symbolic_dense',
               sources = ['sage/matrix/matrix_symbolic_dense.pyx']),
 
@@ -1100,21 +1100,21 @@
 
     Extension('sage.matrix.strassen',
               sources = ['sage/matrix/strassen.pyx']),
-                            
+
     #Extension('sage.matrix.padics.matrix_padic_capped_relative_dense',
     #          sources = ['sage/matrix/padics/matrix_padic_capped_relative_dense.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.media
     ##
     ################################
 
     Extension('sage.media.channels',
-              sources = ['sage/media/channels.pyx']), 
-    
+              sources = ['sage/media/channels.pyx']),
+
     ################################
-    ## 
+    ##
     ## sage.misc
     ##
     ################################
@@ -1183,16 +1183,16 @@
 
     Extension('sage.misc.sage_timeit_class',
               sources = ['sage/misc/sage_timeit_class.pyx']),
-    
-    Extension('sage.misc.classcall_metaclass', 
-              sources = ['sage/misc/classcall_metaclass.pyx']), 
+
+    Extension('sage.misc.classcall_metaclass',
+              sources = ['sage/misc/classcall_metaclass.pyx']),
 
     Extension('sage.misc.fast_methods',
               sources = ['sage/misc/fast_methods.pyx']),
 
     Extension('sage.misc.binary_tree',
               sources = ['sage/misc/binary_tree.pyx']),
-    
+
     Extension('sage.misc.search',
               sources = ['sage/misc/search.pyx']),
 
@@ -1203,7 +1203,7 @@
               sources = ['sage/misc/stopgap.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.modular
     ##
     ################################
@@ -1247,7 +1247,7 @@
               libraries = ['gmp']),
 
     ################################
-    ## 
+    ##
     ## sage.modules
     ##
     ################################
@@ -1258,10 +1258,10 @@
     Extension('sage.modules.free_module_element',
               sources = ['sage/modules/free_module_element.pyx'],
               depends = numpy_depends),
-    
+
     Extension('sage.modules.module',
               sources = ['sage/modules/module.pyx']),
-              
+
     Extension('sage.modules.vector_complex_double_dense',
               ['sage/modules/vector_complex_double_dense.pyx'],
               libraries = [BLAS, BLAS2],
@@ -1273,7 +1273,7 @@
               libraries = [BLAS, BLAS2],
               include_dirs = numpy_include_dirs,
               depends = numpy_depends),
- 
+
     Extension('sage.modules.vector_integer_dense',
               sources = ['sage/modules/vector_integer_dense.pyx'],
               libraries = ['gmp']),
@@ -1287,7 +1287,7 @@
               libraries = ['gmp','m4ri', 'png12', 'gd'],
               extra_compile_args = ['-std=c99'] + m4ri_extra_compile_args,
               depends = [SAGE_INC + "/png.h", SAGE_INC + "/m4ri/m4ri.h"]),
-    
+
     Extension('sage.modules.vector_rational_dense',
               sources = ['sage/modules/vector_rational_dense.pyx'],
               libraries = ['gmp']),
@@ -1303,7 +1303,7 @@
     #           libraries = ['gmp']),
 
     ################################
-    ## 
+    ##
     ## sage.numerical
     ##
     ################################
@@ -1336,7 +1336,7 @@
               libraries=["csage", "stdc++"]),
 
     ################################
-    ## 
+    ##
     ## sage.plot
     ##
     ################################
@@ -1345,21 +1345,21 @@
               sources = ['sage/plot/complex_plot.pyx'],
               include_dirs = numpy_include_dirs,
               depends = numpy_depends),
-    
+
     Extension('sage.plot.plot3d.base',
               sources = ['sage/plot/plot3d/base.pyx'],
               extra_compile_args=["-std=c99"]),
-    
+
     Extension('sage.plot.plot3d.implicit_surface',
               sources = ['sage/plot/plot3d/implicit_surface.pyx'],
               libraries = ['gsl'],
               include_dirs = numpy_include_dirs,
               depends = numpy_depends),
-    
+
     Extension('sage.plot.plot3d.index_face_set',
               sources = ['sage/plot/plot3d/index_face_set.pyx'],
               extra_compile_args=["-std=c99"]),
-    
+
     Extension('sage.plot.plot3d.parametric_surface',
               sources = ['sage/plot/plot3d/parametric_surface.pyx']),
 
@@ -1370,7 +1370,7 @@
               sources = ['sage/plot/plot3d/transform.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.quadratic_forms
     ##
     ################################
@@ -1383,7 +1383,7 @@
               sources = ['sage/quadratic_forms/quadratic_form__evaluate.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.rings
     ##
     ################################
@@ -1423,32 +1423,32 @@
 
     Extension('sage.rings.integer',
               sources = ['sage/rings/integer.pyx'],
-              libraries=['ntl', 'pari', 'flint', 'gmp'], 
-              include_dirs = [SAGE_INC + '/FLINT'], 
+              libraries=['ntl', 'pari', 'flint', 'gmp'],
+              include_dirs = [SAGE_INC + '/FLINT'],
               depends = numpy_depends + flint_depends),
 
     Extension('sage.rings.integer_ring',
               sources = ['sage/rings/integer_ring.pyx'],
               libraries=['ntl', 'gmp']),
 
-    Extension('sage.rings.factorint', 
+    Extension('sage.rings.factorint',
               sources = ['sage/rings/factorint.pyx'],
               libraries=['gmp']),
 
     Extension('sage.rings.fast_arith',
               sources = ['sage/rings/fast_arith.pyx'],
-              libraries=['pari','gmp','csage']), 
+              libraries=['pari','gmp','csage']),
 
     Extension('sage.rings.fraction_field_element',
               sources = ['sage/rings/fraction_field_element.pyx']),
-    
+
     Extension('sage.rings.fraction_field_FpT',
               sources = ['sage/rings/fraction_field_FpT.pyx'],
               libraries = ["csage", "flint", "gmp", "gmpxx", "ntl", "zn_poly"],
               extra_compile_args=["-std=c99", "-D_XPG6"],
               include_dirs = [SAGE_INC + '/FLINT'],
               depends = flint_depends),
-    
+
     Extension('sage.rings.laurent_series_ring_element',
               sources = ['sage/rings/laurent_series_ring_element.pyx']),
 
@@ -1518,7 +1518,7 @@
         ################################
         ##
         ## sage.rings.finite_rings
-        ## 
+        ##
         ################################
 
     Extension('sage.rings.finite_rings.finite_field_base',
@@ -1546,7 +1546,7 @@
         ################################
         ##
         ## sage.rings.function_field
-        ## 
+        ##
         ################################
 
     Extension('sage.rings.function_field.function_field_element',
@@ -1555,7 +1555,7 @@
         ################################
         ##
         ## sage.rings.number_field
-        ## 
+        ##
         ################################
 
     Extension('sage.rings.number_field.number_field_base',
@@ -1570,87 +1570,87 @@
               sources = ['sage/rings/number_field/number_field_element_quadratic.pyx'],
               libraries=['ntl', 'gmp'],
               language = 'c++'),
-  
+
     Extension('sage.rings.number_field.number_field_morphisms',
               sources = ['sage/rings/number_field/number_field_morphisms.pyx']),
 
     Extension('sage.rings.number_field.totallyreal',
               sources = ['sage/rings/number_field/totallyreal.pyx'],
               libraries = ['pari', 'gmp']),
-    
+
     Extension('sage.rings.number_field.totallyreal_data',
               sources = ['sage/rings/number_field/totallyreal_data.pyx'],
               libraries = ['gmp'],
               depends = numpy_depends),
-    
+
         ################################
         ##
         ## sage.rings.padics
-        ## 
+        ##
         ################################
-    
+
     Extension('sage.rings.padics.local_generic_element',
               sources = ['sage/rings/padics/local_generic_element.pyx']),
-    
+
     Extension('sage.rings.padics.padic_base_coercion',
               sources = ['sage/rings/padics/padic_base_coercion.pyx'],
               libraries=['gmp']),
-    
+
     Extension('sage.rings.padics.padic_base_generic_element',
               sources = ['sage/rings/padics/padic_base_generic_element.pyx'],
               libraries=['gmp']),
-    
+
     Extension('sage.rings.padics.padic_capped_absolute_element',
               sources = ['sage/rings/padics/padic_capped_absolute_element.pyx'],
               libraries=['gmp']),
-    
+
     Extension('sage.rings.padics.padic_capped_relative_element',
               sources = ['sage/rings/padics/padic_capped_relative_element.pyx'],
               libraries=['gmp', 'csage']),
-    
+
     Extension('sage.rings.padics.padic_ext_element',
               sources = ['sage/rings/padics/padic_ext_element.pyx'],
               libraries=['ntl', 'gmp', 'csage', 'gmpxx', 'm', 'stdc++'],
               language='c++'),
-    
+
     Extension('sage.rings.padics.padic_fixed_mod_element',
               sources = ['sage/rings/padics/padic_fixed_mod_element.pyx'],
               libraries=['gmp']),
-    
+
     Extension('sage.rings.padics.padic_generic_element',
               sources = ['sage/rings/padics/padic_generic_element.pyx'],
               libraries=['gmp']),
-    
+
     Extension('sage.rings.padics.padic_printing',
               sources = ['sage/rings/padics/padic_printing.pyx'],
               libraries=['gmp', 'ntl', 'csage', 'gmpxx', 'm', 'stdc++'],
               language='c++'),
-    
+
     Extension('sage.rings.padics.padic_ZZ_pX_CA_element',
               sources = ['sage/rings/padics/padic_ZZ_pX_CA_element.pyx'],
               libraries = ['ntl', 'gmp', 'csage','gmpxx','m','stdc++'],
               language='c++'),
-    
+
     Extension('sage.rings.padics.padic_ZZ_pX_CR_element',
               sources = ['sage/rings/padics/padic_ZZ_pX_CR_element.pyx'],
               libraries=['ntl', 'gmp', 'csage','gmpxx','m','stdc++'],
               language='c++'),
-    
+
     Extension('sage.rings.padics.padic_ZZ_pX_element',
               sources = ['sage/rings/padics/padic_ZZ_pX_element.pyx'],
               libraries=['ntl', 'gmp', 'csage', 'gmpxx', 'm', 'stdc++'],
               language='c++'),
-    
+
     Extension('sage.rings.padics.padic_ZZ_pX_FM_element',
               sources = ['sage/rings/padics/padic_ZZ_pX_FM_element.pyx'],
               libraries=['ntl', 'gmp', 'csage', 'gmpxx', 'm', 'stdc++'],
               language='c++'),
-    
+
     Extension('sage.rings.padics.pow_computer',
               sources = ['sage/rings/padics/pow_computer.pyx'],
               libraries = ["csage", "ntl", "gmp", "gmpxx", "m", "stdc++"],
               language='c++'),
-    
+
     Extension('sage.rings.padics.pow_computer_ext',
               sources = ['sage/rings/padics/pow_computer_ext.pyx'],
               libraries = ["csage", "ntl", "gmp", "gmpxx", "m", "stdc++"],
@@ -1659,17 +1659,17 @@
         ################################
         ##
         ## sage.rings.polynomial
-        ## 
+        ##
         ################################
-    
+
     Extension('sage.rings.polynomial.cyclotomic',
-              sources = ['sage/rings/polynomial/cyclotomic.pyx']), 
+              sources = ['sage/rings/polynomial/cyclotomic.pyx']),
 
     Extension('sage.rings.polynomial.laurent_polynomial',
               sources = ['sage/rings/polynomial/laurent_polynomial.pyx']),
 
     Extension('sage.rings.polynomial.multi_polynomial',
-              sources = ['sage/rings/polynomial/multi_polynomial.pyx']), 
+              sources = ['sage/rings/polynomial/multi_polynomial.pyx']),
 
     Extension('sage.rings.polynomial.multi_polynomial_ideal_libsingular',
               sources = ['sage/rings/polynomial/multi_polynomial_ideal_libsingular.pyx'],
@@ -1696,7 +1696,7 @@
               extra_compile_args = givaro_extra_compile_args),
 
     Extension('sage.rings.polynomial.multi_polynomial_ring_generic',
-              sources = ['sage/rings/polynomial/multi_polynomial_ring_generic.pyx']), 
+              sources = ['sage/rings/polynomial/multi_polynomial_ring_generic.pyx']),
 
     Extension('sage.rings.polynomial.polydict',
               sources = ['sage/rings/polynomial/polydict.pyx']),
@@ -1780,11 +1780,15 @@
               sources = ['sage/rings/polynomial/symmetric_reduction.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.schemes
     ##
     ################################
 
+    Extension("sage.schemes.elliptic_curves.chow_heegner_fast",
+              sources = ["sage/schemes/elliptic_curves/chow_heegner_fast.pyx"],
+              libraries = ['gmp', 'mpfr', 'gsl', 'cblas', 'atlas']),
+
     Extension('sage.schemes.elliptic_curves.descent_two_isogeny',
               sources = ['sage/schemes/elliptic_curves/descent_two_isogeny.pyx'],
               extra_compile_args=["-std=c99"],
@@ -1809,10 +1813,10 @@
 
     Extension('sage.schemes.toric.divisor_class',
               sources = ['sage/schemes/toric/divisor_class.pyx'],
-              libraries = ['gmp']),              
+              libraries = ['gmp']),
 
     ################################
-    ## 
+    ##
     ## sage.sets
     ##
     ################################
@@ -1825,7 +1829,7 @@
               depends = flint_depends),
 
     ################################
-    ## 
+    ##
     ## sage.stats
     ##
     ################################
@@ -1835,19 +1839,19 @@
 
     Extension('sage.stats.hmm.distributions',
               sources = ['sage/stats/hmm/distributions.pyx']),
-    
+
     Extension('sage.stats.hmm.hmm',
               sources = ['sage/stats/hmm/hmm.pyx']),
 
     Extension('sage.stats.hmm.chmm',
               sources = ['sage/stats/hmm/chmm.pyx'],
               extra_compile_args=["-std=c99"]),
-    
+
     Extension('sage.stats.intlist',
               sources = ['sage/stats/intlist.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.structure
     ##
     ################################
@@ -1891,7 +1895,7 @@
 
     Extension('sage.structure.parent_base',
               sources = ['sage/structure/parent_base.pyx']),
-    
+
     Extension('sage.structure.parent_gens',
               sources = ['sage/structure/parent_gens.pyx']),
 
@@ -1905,7 +1909,7 @@
               sources = ['sage/structure/wrapper_parent.pyx']),
 
     ################################
-    ## 
+    ##
     ## sage.symbolic
     ##
     ################################
@@ -1920,13 +1924,13 @@
               language = 'c++',
               depends = ginac_depends,
               libraries = ["pynac", "gmp"]),
-    
+
     Extension('sage.symbolic.getitem',
               sources = ['sage/symbolic/getitem.pyx'],
               language = 'c++',
               depends = [SAGE_INC + "/pynac/ginac.h"],
               libraries = ["pynac", "gmp"]),
-    
+
     Extension('sage.symbolic.function',
               sources = ['sage/symbolic/function.pyx'],
               language = 'c++',
@@ -1937,8 +1941,8 @@
               sources = ['sage/symbolic/pynac.pyx'],
               language = 'c++',
               depends = ginac_depends,
-              libraries = ["pynac", "gmp", "gsl"]),
-    
+              libraries = ["pynac", "gmp", "gsl", BLAS, BLAS2]),
+
     Extension('sage.symbolic.ring',
               sources = ['sage/symbolic/ring.pyx'],
               language = 'c++',
@@ -1946,7 +1950,7 @@
               libraries = ["pynac", "gmp"]),
 
     ################################
-    ## 
+    ##
     ## sage.tests
     ##
     ################################
@@ -1957,12 +1961,12 @@
               sources = ['sage/tests/stl_vector.pyx'],
               libraries = ['gmp'],
               language = 'c++'),
-    
+
     Extension('sage.tests.cython',
               sources = ['sage/tests/cython.pyx']),
-    
+
     ################################
-    ## 
+    ##
     ## sage.sat
     ##
     ################################
@@ -1987,7 +1991,7 @@
        ])
 
 
-if (os.path.isfile(SAGE_INC + "gurobi_c.h") and                                                                                                                                                                                   
+if (os.path.isfile(SAGE_INC + "gurobi_c.h") and
     os.path.isfile(SAGE_LOCAL + "/lib/libgurobi.so")):
     ext_modules.append(
         Extension("sage.numerical.backends.gurobi_backend",
@@ -2008,19 +2012,19 @@
         )
 
 
-if (os.path.isfile(SAGE_INC + "/cplex.h") and                                                                                                                                                                                   
+if (os.path.isfile(SAGE_INC + "/cplex.h") and
     os.path.isfile(SAGE_LOCAL + "/lib/libcplex.a")):
     ext_modules.append(
-        Extension("sage.numerical.backends.cplex_backend",                                                                                                                                                                                    
-                  ["sage/numerical/backends/cplex_backend.pyx"],                                                                                                                                                                              
-                  include_dirs = [SAGE_INC, "sage/c_lib/include/"],                                                                                                                                                        
-                  language = 'c',                                                                                                                                                                                                             
-                  libraries = ["csage", "stdc++", "cplex"]) 
+        Extension("sage.numerical.backends.cplex_backend",
+                  ["sage/numerical/backends/cplex_backend.pyx"],
+                  include_dirs = [SAGE_INC, "sage/c_lib/include/"],
+                  language = 'c',
+                  libraries = ["csage", "stdc++", "cplex"])
         )
 
 if is_package_installed('cbc'):
     ext_modules.append(
-        Extension("sage.numerical.backends.coin_backend",                                                                                                                                                                                     
+        Extension("sage.numerical.backends.coin_backend",
                   ["sage/numerical/backends/coin_backend.pyx"],
                   include_dirs = [SAGE_INC, "sage/c_lib/include/"],
                   language = 'c++',
diff --git a/sage/__init__.py b/sage/__init__.py
--- a/sage/__init__.py
+++ b/sage/__init__.py
@@ -1,1 +1,1 @@
-__all__ = ['all']
+#__all__ = ['all']
diff --git a/sage/schemes/elliptic_curves/chow_heegner.py b/sage/schemes/elliptic_curves/chow_heegner.py
new file mode 100644
--- /dev/null
+++ b/sage/schemes/elliptic_curves/chow_heegner.py
@@ -0,0 +1,2074 @@
+##############################################################################
+#       Copyright (C) 2011 William Stein <wstein@gmail.com>
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#    This code is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#    General Public License for more details.
+#
+#  The full text of the GPL is available at:
+#
+#                  http://www.gnu.org/licenses/
+##############################################################################
+"""
+Chow-Heegner Points
+
+This is a package for numerically computing Chow-Heegner points
+associated to pairs (E,F) of non-isogenous optimal elliptic curves
+over the rational numbers of the same conductor. For a description of
+the algorithm, see http://wstein.org/papers/chow_heegner/.
+
+AUTHORS:
+    - William Stein (November 2011)
+
+EXAMPLES::
+
+    sage: P = EllipticCurve('57a').chow_heegner_point(EllipticCurve('57b'))
+    sage: P.numerical_approx(deg1=100)
+    (1.44444444444... : -1.03703703703... : 1.00000000000000)
+    sage: P.point_exact(deg1=100)
+    (13/9 : -28/27 : 1)
+    sage: P.index(deg1=100)
+    8
+    
+TESTS::
+
+    sage: P = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b'))
+    sage: TestSuite(P).run()
+"""
+
+# General Sage imports
+from sage.misc.all import (cached_method, cputime, verbose, parent)
+from sage.parallel.all import parallel
+from sage.rings.all import (QQ, ZZ, CDF, RDF, RR, infinity, xgcd,
+        NumberField, ComplexField, is_ComplexField, is_RationalField)
+from sage.modular.all import Gamma0
+
+# Elliptic curve imports
+from constructor import EllipticCurve
+from ell_generic import is_EllipticCurve
+
+# Fast Cython functions specifically for this code.
+from sage.schemes.elliptic_curves.chow_heegner_fast import (
+    cdf_roots_of_rdf_poly, Polynomial_RDF_gsl, ComplexPolynomial)
+
+######################################################################
+# Gamma0(N) equivalence of points in the upper half plane
+######################################################################
+
+def sl2z_rep_in_fundom(z):
+    """
+    Return element of the standard fundamental domain for SL2Z
+    equivalent to z and a transformation in SL2Z mapping z to that
+    element.
+
+    INPUT:
+        - `z` -- floating point complex number in the upper half plane
+
+    OUTPUT:
+        - element of upper half plane
+        - 2x2 integer matrix of determinant 1
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import sl2z_rep_in_fundom
+        sage: z = CDF(2.17,.19)
+        sage: w, g = sl2z_rep_in_fundom(z)     
+        sage: w
+        0.384615384615 + 2.92307692308*I
+        sage: g
+        [-3  7]
+        [-1  2]
+        sage: (g[0,0]*z + g[0,1])/(g[1,0]*z + g[1,1])
+        0.384615384615 + 2.92307692308*I
+    """
+    # The standard algorithm to do this is to replace z by z-n
+    # and z by -1/z until |Re(z)|<=1/2 and |z|>=1.
+
+    from sage.modular.all import SL2Z
+    gamma = SL2Z(1)
+    S, T = SL2Z.gens()
+    change = True
+    half = z.real().parent()(1)/2
+    while change:
+        change = False
+        t = z.real()
+        if abs(t) > half:
+            change = True
+            # |t - n| <= 1/2
+            # -1/2 <= t-n <= 1/2
+            # n - 1/2 <= t < = 1/2+n
+            # n <= t + 1/2 <= n + 1, so n = floor(t+1/2)
+            n = (t + half).floor()  # avoid rounding error with 0.5
+            #print "t = ", t, "  n = ", n
+            z -= n
+            #print "subtract", n
+            if hasattr(n, 'center'):
+                k = round(n.center())
+            else:
+                k = n
+            gamma *= T**k
+        if abs(z) < 1:
+            change = True
+            #print "invert"
+            z = -1/z
+            gamma *= S
+    return z, gamma**(-1)
+        
+
+def canonicalize_sl2z(a, g=None, eps_ratio=2):
+    """
+    Assume that a = g(z) is in the fundamental domain for SL2Z.
+    Adjust a by applying T^(-1) or S so that a is the canonical
+    representative in the fundamental domain, so a is not on the right
+    edge, and if a is on the unit circle, then it is on the left hand
+    side.  Also, modify g so that the relation a = g(z) continues to
+    hold.
+
+    Special case: if g is None, just adjust a, ignoring g.
+
+    INPUT:
+        - a -- element of fundamental domain (so in ComplexField(prec))
+        - g -- None or element of SL2Z
+        - eps_ratio -- default 2; used in testing equality of the floating
+          point number a with 1 and 1/2. See comment in source code. 
+
+    OUTPUT:
+        - new a and a matrix g (or None)
+
+    EXAMPLES::
+
+    When a is on the right edge::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import canonicalize_sl2z
+        sage: g = SL2Z([1,0,0,1])
+        sage: canonicalize_sl2z(CDF(1/2, 1), g)
+        (-0.5 + 1.0*I, [ 1 -1]
+        [ 0  1])    
+
+    Don't bother to compute the matrix g::
+
+        sage: canonicalize_sl2z(CDF(1/2, 1))
+        (-0.5 + 1.0*I, None)
+
+    A higher precision example::
+
+        sage: canonicalize_sl2z(ComplexField(200)(1/2,1))
+        (-0.50000000000000000000000000000000000000000000000000000000000 + 1.0000000000000000000000000000000000000000000000000000000000*I, None)    
+
+    When a is on the right side of the unit circle::
+
+        sage: canonicalize_sl2z(CDF(1/sqrt(2),1/sqrt(2)), SL2Z([1,0,0,1]))
+        (-0.707106781187 + 0.707106781187*I, [ 0 -1]
+        [ 1  0])    
+
+    When a is in the middle (so a does not change)::
+
+        sage: canonicalize_sl2z(CDF(0,1), SL2Z([1,0,0,1]))
+        (1.0*I, [1 0]
+        [0 1])    
+
+    Using a bigger eps_ratio makes it so comparison of floating point
+    numbers is less sensitive::
+    
+        sage: canonicalize_sl2z(CDF(0.500001, 1))
+        (0.500001 + 1.0*I, None)
+        sage: canonicalize_sl2z(CDF(0.500001, 1), eps_ratio=4)
+        (-0.499999 + 1.0*I, None)
+    """
+    if g is not None:
+        S, T = g.parent().gens()
+    # There are two cases where points on boundary are identified,
+    # as explained in Theorem 1 of Chapter VII of Serre's "A Course
+    # in Arithmetic".
+    # Here we have to check for equality of a floating point number
+    # with 1/2 and with 1.  In each case, exact equality of course
+    # almost never happens, so we must use some notion of "eps",
+    # and we use eps=2**(-prec//eps_ratio), where prec is the number of bits
+    # of precision of the parent, and eps_ratio=2 by default. 
+    C = a.parent()
+    eps = 2**(-C.prec() // eps_ratio)
+    if abs(a.real() - C(1)/2)<eps:
+        a -= 1
+        if g is not None: g = T**(-1)*g
+    elif abs(abs(a) - 1)<eps and a.real() > 0:
+        # points are sl2z equivalent on boundary of unit circle
+        a = -1/a
+        if g is not None: g = S*g
+    return a, g
+
+def is_sl2z_equivalent(z1, z2, prec):
+    """
+    Return True if the complex numbers z1 and z2 in the upper half
+    plane are equivalent modulo the action of SL_2(Z), at least to the
+    given number prec of bits of absolute precision.  Canonical
+    representatives equivalent to z1 and z2 are found, and declared
+    equal if the absolute value of their difference is less than
+    2**(-prec).
+    
+    INPUT:
+        - `z_1`, `z_2` -- floating point complex numbers in the upper
+          half plane
+        - ``prec`` -- positive integer (bits of absolute precision)
+    
+    OUTPUT:
+        - bool
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import is_sl2z_equivalent
+
+    Trivial special case::
+    
+        sage: is_sl2z_equivalent(CDF(5,7), CDF(5,7), 53)
+        True
+
+    Apply an element of SL2Z, and note that precision 53 fails do to
+    rounding errors, though 40 bits works::
+
+        sage: z1 = CDF(5,7)
+        sage: z2 = (-5*z1 - 6)/(11*z1 + 13); z2
+        -0.455131242301 + 0.000663318487634*I
+        sage: is_sl2z_equivalent(z1, z2, 53)
+        False
+        sage: is_sl2z_equivalent(z1, z2, 40)
+        True
+
+    Here the two elements are not equivalent::
+    
+        sage: is_sl2z_equivalent(z1, .5*z2, 20)
+        False
+
+    This is the same as above, but to higher precision::
+    
+        sage: z1 = ComplexField(200)(5,7)
+        sage: z2 = (-5*z1 - 6)/(11*z1 + 13)
+        sage: is_sl2z_equivalent(z1, z2, 150)
+        True    
+    """
+    w1, _ = sl2z_rep_in_fundom(z1)
+    w2, _ = sl2z_rep_in_fundom(z2)
+    a1, _ = canonicalize_sl2z(w1)
+    a2, _ = canonicalize_sl2z(w2)
+    return abs(a1 - a2) < 2**(-prec)
+
+def is_gamma0N_equivalent(z1, z2, N, prec):
+    """
+    Return True if z1 and z2 are equivalent modulo the action of
+    `\\Gamma_0(N)`` to the given number of bits of precision.
+
+    INPUT:
+        - `z_1`, `z_2` -- floating point complex numbers in the upper
+          half plane
+        - `N` -- positive integer  
+        - ``prec`` -- positive integer (bits of absolute precision)
+
+    OUTPUT:
+        - bool
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import is_gamma0N_equivalent
+
+    Construct a point and its image via the action of a matrix in
+    Gamma0(11), and do some basic checks::
+
+        sage: z1 = CDF(5,7)
+        sage: z2 = (-5*z1 - 6)/(11*z1 + 13); z2
+        -0.455131242301 + 0.000663318487634*I
+        sage: is_gamma0N_equivalent(z1, z2, 11, 30)
+        True
+        sage: is_gamma0N_equivalent(z1, z2, 12, 30)
+        False
+
+    Test under image of all generators of Gamma0(12))::
+    
+        sage: all(is_gamma0N_equivalent(z1, g.acton(z1), 12, 30) for g in Gamma0(12).gens())
+        True
+
+    Test to higher precision using Gamma0(15)::
+
+        sage: z1 = ComplexField(200)(5,7)
+        sage: all(is_gamma0N_equivalent(z1, g.acton(z1), 15, 150) for g in Gamma0(15).gens())
+        True        
+    """
+    if not is_sl2z_equivalent(z1, z2, prec):
+        # points are not even sl2z-equivalent, so they can't
+        # be Gamma_0(N) equivalent
+        return False
+    # Now we know the two points are SL2Z-equivalent.
+    # Next check further if N*z1 is equivalent to N*z2.
+    return is_sl2z_equivalent(N*z1, N*z2, prec)
+
+
+class X0NPoint(object):
+    """
+    An affine point on the modular curve `X_0(N)` represented as a
+    floating point complex number.  We use this for representing
+    points in the fiber over a point on an elliptic curve.
+
+    TESTS::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import X0NPoint
+        sage: x = X0NPoint(CDF(1,1), 11, 30)
+        sage: TestSuite(x).run()    
+    """
+    def __init__(self, z, N, prec):
+        """
+        INPUT:
+            - `z` -- floating point complex number in the upper half plane
+            - `N` -- positive integer
+            - `prec` -- positive integer; bits of precision used in comparisons
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import X0NPoint
+            sage: x = X0NPoint(CDF(1,1), 11, 30); x
+            [1.0000000 + 1.0000000*I]
+            sage: type(x)
+            <class 'sage.schemes.elliptic_curves.chow_heegner.X0NPoint'>        
+        """
+        self._z = z
+        self._N = N
+        self._prec = prec
+        self._C = ComplexField(prec)
+
+    def z(self):
+        """
+        Return representative point z in the upper half plane as a
+        floating point number.
+        
+        EXAMPLES::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner import X0NPoint
+            sage: X0NPoint(CDF(1,1), 11, 30).z()
+            1.0 + 1.0*I
+        """
+        return self._z
+        
+    def __cmp__(self, right):
+        """
+        Compare self and right, which must have the same level N and
+        compare prec.  The points are considered equal if the two
+        points are equivalent modulo the action of Gamma0(N) to the
+        given precision.  If not equivalent, compares underlying
+        floating point representatives as complex numbers.
+        
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import X0NPoint
+            sage: z = CDF(1,1); x=X0NPoint(z,11,30); y=X0NPoint((-5*z-1)/(11*z+2),11,30)
+            sage: x==y
+            True
+            sage: z = CDF(1,1); x=X0NPoint(z,11,30); y=X0NPoint(z/2,11,30)
+            sage: x==y
+            False        
+        """
+        assert self._N == right._N and self._prec == right._prec
+        if self._N == 1:
+            return cmp(self._sl2z_rep(), right.sl2z_rep())
+        if is_gamma0N_equivalent(self._z, right._z, self._N, self._prec):
+            return 0
+        return cmp(self._z, right._z)
+
+    def __repr__(self):
+        """
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import X0NPoint
+            sage: X0NPoint(CDF(1,1), 11,30).__repr__()
+            '[1.0000000 + 1.0000000*I]'        
+        """
+        return "[%s]"%self._C(self._z)
+
+    @cached_method
+    def sl2z_rep(self):
+        """
+        Canonical element of fundamental domain for SL2Z that is
+        equivalent to self.
+        
+        EXAMPLES::
+
+            sage: import sage.schemes.elliptic_curves.chow_heegner as h
+            sage: h.X0NPoint(CDF(2,.1), 11,30).sl2z_rep()
+            10.000000*I
+            sage: h.sl2z_rep_in_fundom(CDF(2,.1))[0]
+            10.0*I        
+        """
+        a = self._C(sl2z_rep_in_fundom(self._z)[0])
+        b = canonicalize_sl2z(a)[0]
+        return b
+
+    def atkin_lehner(self, q=None):
+        """
+        Return image of this point under the Atkin-Lehner involution W_q.
+        
+        INPUT:
+            - `q` -- prime power that exactly divides the level, or
+              None, in which q is the level
+         
+        OUTPUT:
+            - X0NPoint
+        
+        EXAMPLES::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner import X0NPoint
+            sage: x = X0NPoint(CDF(1,1), 12, 30); x.atkin_lehner()
+            [-0.041666667 + 0.041666667*I]
+            sage: x.atkin_lehner().atkin_lehner()
+            [1.0000000 + 1.0000000*I]
+            sage: x.atkin_lehner(4)
+            [0.32000000 + 0.010000000*I]
+            sage: x.atkin_lehner(3)
+            [-0.26016260 + 0.0081300813*I]
+            sage: x.atkin_lehner(3).atkin_lehner(3)
+            [1.0000000 + 1.0000000*I]
+            sage: x.atkin_lehner(2)
+            Traceback (most recent call last):
+            ...
+            ValueError: q must exactly divide N
+            sage: x.atkin_lehner(5)
+            Traceback (most recent call last):
+            ...
+            ValueError: q must divide N        
+        """
+        if q is None:
+            # Main involution
+            z, N, prec = self._z, self._N, self._prec
+            return X0NPoint(-1/(N*z), N, prec)
+        else:
+            z, N, prec = self._z, self._N, self._prec
+            q = ZZ(q)
+            if N%q != 0:
+                raise ValueError, "q must divide N"
+            g, x, y = xgcd(q, -N//q)
+            if g != 1:
+                raise ValueError, "q must exactly divide N"
+            # Now q*x - (N//q)*y = 1
+            # W_q = [q*x,  y;  N,  q]
+            return X0NPoint((q*x*z + y)/(N*z + q), N, prec)
+        
+    def __hash__(self):
+        """
+        We return 0 for the hash, which is useful so that we can use
+        the data structures such as sets in Python with these points,
+        though with a severe performance penalty.
+            
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import X0NPoint
+            sage: X0NPoint(CDF(1,1), 12, 30).__hash__()
+            0        
+        """
+        return 0
+
+def disk_to_h(q):
+    """
+    Given a floating point complex number q in the open unit disk,
+    return a point tau in the upper half plane such that q =
+    exp(2*pi*I*tau).
+
+    NOTE: This function is just a scaled version of log, so it works
+    for any nonzero complex number.
+
+    INPUT:
+        - q -- complex number in unit disk
+    OUTPUT:
+        - complex number in upper half plane
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import disk_to_h, h_to_disk
+        sage: disk_to_h(CDF(.5,.3))
+        0.0860104348113 + 0.0858489451313*I
+        sage: disk_to_h(ComplexField(100)(.5,.3))
+        0.086010434811315337269743555113 + 0.085848945131318196784916564927*I        
+        sage: h_to_disk(disk_to_h(CDF(.5,.3)))
+        0.5 + 0.3*I
+    """
+    K = q.parent()
+    return q.log() / (2*K.pi()*K.gen())
+
+def h_to_disk(z):
+    """
+    Given a floating point complex number z in the upper half plane,
+    return the image of z under the map exp(2*pi*I*z), which is in the
+    unit disk.
+
+    NOTE: This function is just a scaled version of exp, so it works
+    for any complex number.
+
+    INPUT:
+        - z -- complex number in upper half plane
+    OUTPUT:
+        - complex number in unit disk
+
+    EXAMPLES::
+        
+        sage: from sage.schemes.elliptic_curves.chow_heegner import disk_to_h, h_to_disk
+        sage: h_to_disk(CDF(0,2))
+        3.48734235621e-06
+        sage: disk_to_h(h_to_disk(CDF(0,2)))
+        2.0*I
+        sage: h_to_disk(CDF(2,1))
+        0.00186744273171 - ...e-19*I
+
+    Notice that the two maps are not mutual inverses, since the result
+    of disk_to_h is always (approximately) in the vertical strip from
+    0 to 1::
+    
+        sage: disk_to_h(h_to_disk(CDF(2,1)))
+        -...e-17 + 1.0*I
+        sage: disk_to_h(h_to_disk(CDF(0,1)))
+        1.0*I        
+    """
+    K = z.parent()
+    return (2*K.pi()*K.gen()*z).exp()
+
+class CloseEqual:
+    """
+    Object used in the throw_away_close function.
+
+    TESTS::
+    
+        sage: from sage.schemes.elliptic_curves.chow_heegner import CloseEqual
+        sage: c = CloseEqual(CDF(1,1), ComplexField(30))
+        sage: TestSuite(c).run()    
+    """
+    def __init__(self, x, C):
+        """
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import CloseEqual
+            sage: c = CloseEqual(CDF(1,1), ComplexField(30)); c
+            <sage.schemes.elliptic_curves.chow_heegner.CloseEqual instance at 0x...>
+            sage: c.x, c.y
+            (1.0 + 1.0*I, 1.0000000 + 1.0000000*I)        
+        """
+        self.x = x
+        self.y = C(x)
+        
+    def __hash__(self):
+        """
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import CloseEqual
+            sage: c = CloseEqual(CDF(1,1), ComplexField(30)); c.__hash__()
+            1000004
+            sage: hash(c.y)
+            1000004        
+        """
+        return hash(self.y)
+    
+    def __cmp__(self, right):
+        """
+        Compare the images of x in C.
+        
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import CloseEqual
+            sage: c = CloseEqual(CDF(1,1), ComplexField(30))
+            sage: c2 = CloseEqual(CDF(1,1)+2^(-32), ComplexField(30))
+            sage: c == c2
+            True
+            sage: c.x == c2.x
+            False        
+        """
+        return cmp(self.y, right.y)
+
+def throw_away_close(v, prec):
+    """
+    Return list of 'distinct' elements of v, where we consider two
+    elements close if they agree when coerced to complex numbers to
+    prec bits of precision.
+
+    INPUT:
+        - `v` -- list of floating point numbers
+        - ``prec`` -- integer; bits of precision to do comparisons
+
+    OUTPUT:
+        - sorted list of unique elements of v, where unique is defined
+          as equality in ComplexField(prec)
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import throw_away_close
+        sage: v = [CDF(1,1), CDF(1,1)+2^(-32), CDF(1,1)+2^(-20)]
+
+    All are distinct::
+    
+        sage: throw_away_close(v, 53)
+        [1.0 + 1.0*I, 1.00000000023 + 1.0*I, 1.00000095367 + 1.0*I]
+
+    Now v[1] and v[0] considered same::
+    
+        sage: throw_away_close(v, 30)
+        [1.0 + 1.0*I, 1.00000095367 + 1.0*I]
+
+    Now all the same::
+    
+        sage: throw_away_close(v, 20)
+        [1.0 + 1.0*I]
+
+    But not to slightly higher precision::
+    
+        sage: throw_away_close(v, 21)
+        [1.0 + 1.0*I, 1.00000095367 + 1.0*I]    
+    """
+    C = ComplexField(prec)
+    w = [a.x for a in set([CloseEqual(x, C) for x in v])]
+    w.sort()
+    return w
+
+def newton(f, x, max_iter=1000, max_err=1e-14):
+    """
+    Use the given number of steps of the Newton's algorithm to refine
+    the given approximate root(s) x of f, where x is either a single
+    root or a list of roots.  Returns list of refined roots, number of
+    iterations, and an error bound.
+
+    If the precision of base field of f is at most 53 and the
+    coefficients are in fact real, then this function is particularly
+    fast.
+
+    INPUT:
+        - `f` -- polynomial over a floating point complex field.
+        - `x` -- an approximate root or *list* of approximate roots.
+        - ``max_iter`` -- positive integer (default: 1000)
+        - ``max_err`` -- small real (default: 1e-14)
+
+    OUTPUT:
+        - list of triples (r, n, err), where r is the root found via n
+          iterations, where the iteration stopped because the
+          difference between the n and n-1 value was err < max_err.
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import newton
+        sage: R.<x> = CDF[]; f = x^3 + x - 3
+
+    Starting value of 1 (not a list)::
+    
+        sage: t = newton(f, 1); t 
+        [(1.21341166276, 6, 0.0)]
+
+    Resulting value is an approximate root as required::
+    
+        sage: f(t[0][0])
+        -4.4408920985e-16
+
+    In the following, we input three different starting values.  The
+    first two converge to the same root, and the third to a different
+    imaginary root::
+    
+        sage: t = newton(f, [1, 5, -.6-1.4*I]); t 
+        [(1.21341166276, 6, 0.0), (1.21341166276, 9, 0.0), (-0.606705831381 - 1.45061224919*I, 5, 0.0)]
+
+    An example in which f has precision less than 53 bits::
+
+        sage: R.<x> = ComplexField(30)[]; f = x^3 + x - 3
+        sage: t = newton(f, [1]); t 
+        [(1.2134117, 6, 0.0)]
+        sage: f(t[0][0])
+        0    
+
+    An example in which f has complex coefficients but precision 53 bits::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import newton
+        sage: R.<x> = CDF[]; f = x^3 + CDF.0*x - 3; f
+        x^3 + I*x - 3.0
+        sage: t = newton(f, 1); t
+        [(1.44257744162 - 0.233096549477*I, 7, 2.77555756156e-17)]
+        sage: f(t[0][0])
+        4.4408920985e-16 - 1.11022302463e-16*I    
+
+    An example in which f has higher precision::
+
+        sage: R.<x> = ComplexField(100)[]; f = x^3 + x - 3
+        sage: t = newton(f, [1]); t
+        [(1.2134116627622296341321313774, 6, 2.1019987680519080567000919351e-26)]
+
+    Example with higher degree and precision::
+
+        sage: R.<x> = ComplexField(500)[]; f = R([1..100])
+        sage: t = newton(f, [1]); t
+        [(-0.9485943966031...82, 34, 5.042484221...964289e-15)]
+
+    However, the root we get isn't much better, due to not shrinking max_err::
+    
+        sage: f(t[0][0])
+        -3.64698728...1825369e-26
+
+    By shrinking max_err from the default, we get a much better answer::
+    
+        sage: t = newton(f, [1], max_err=2.0^(-400))
+        sage: f(t[0][0])
+        -2.443949090...136e-150
+
+    Note that max_err is not a bound on f(approx_root).  Instead it is
+    a bound on the difference of successive Newton approximations to
+    the root.  For example, with max_err=0, we get::
+
+        sage: t = newton(f, [1], max_err=0)
+        sage: t[0][1]  # number of iterations
+        39
+        sage: f(t[0][0])      # error greater than 0
+        -2.443949090...49136e-150
+        sage: t[0][2]         # difference in successive approximations is 0 to our prec 500
+        0.0000000...000000000    
+    """
+    C = f.base_ring()
+
+    if C.prec() <= 53:
+        try:
+            g = f.change_ring(RDF)
+        except TypeError:
+            # coefficients not real        
+            if C == CDF:
+                f = f.change_ring(ComplexField(53))
+        else:
+            t = Polynomial_RDF_gsl(g).newton(x, max_iter=max_iter, max_err=max_err)
+            if C != CDF:
+                t = [(C(v[0]), v[1], v[2]) for v in t]
+            return t
+
+    if not isinstance(x, list):
+        x = [x]
+
+    f_prime = f.derivative()
+
+    # ComplexPolynomial(...) is roughly 10 times faster to evaluate
+    # than a usual Sage polynomial over a higher precision complex
+    # field, so we use it instead.
+    tm = verbose("Running Newton refinement on degree %s polynomial to precision %s on %s roots"%(
+        f.degree(), C.prec(), len(x)))
+    f = ComplexPolynomial(f); f_prime = ComplexPolynomial(f_prime)
+    ans = []
+    for root in x:
+        root = C(root)
+        last_root = root
+        g_root = C(root)
+        for i in range(max_iter):
+            root = root - f(root)/f_prime(root)
+            err = abs(last_root - root)
+            if  err <= max_err:
+                break
+            last_root = root
+        ans.append((root, i+1, err))
+        verbose("Newton iterations: %s"%i)
+    verbose("Completed %s Newton refinements in %s seconds."%(len(x), cputime(tm)))
+    return ans
+
+class NumericalPoint(object):
+    """
+    A wrapper around a numerical approximation to a point on an
+    elliptic curve over QQ with several extra convenience functions.
+
+    EXAMPLES::
+
+        sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=130)
+        sage: Q
+        (6.00000000000... : 14.0000000000... : 1.00000000000000)
+        sage: Q._eps
+        0.0001
+        sage: Q._P
+        (6.00000000000... : 14.0000000000... : 1.00000000000000)
+
+    TESTS::
+
+        sage: TestSuite(Q).run()    
+    """
+    def __init__(self, P, eps):
+        """
+        INPUT:
+            - `P` -- actual point on some elliptic curve over a floating point base field
+            - ``eps`` -- small positive real
+
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=100)
+            sage: type(Q)
+            <class 'sage.schemes.elliptic_curves.chow_heegner.NumericalPoint'>
+        """
+        self._P = P
+        self._eps = eps
+
+    def curve(self):
+        """
+        Return the curve over a floating point base field that this
+        point is on.
+        
+        EXAMPLES::
+        
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=100)
+            sage: Q.curve()
+            Elliptic Curve defined by y^2 + 1.00000000000000*y = x^3 + (-1.00000000000000)*x over Complex Field with 53 bits of precision
+        """
+        return self._P.curve()
+
+    def rational_curve(self):
+        """
+        Return the elliptic curve that this point is on, but over the
+        rational numbers.
+
+        EXAMPLES::
+        
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=100)
+            sage: Q.rational_curve()
+            Elliptic Curve defined by y^2 + y = x^3 - x over Rational Field
+        """
+        return EllipticCurve(QQ,[int(a.real()) for a in self._P.curve().a_invariants()])
+
+    def close_points(self, search_bound, eps=1e-3):
+        """
+        Return points close to self, sorted by distance (with closed point first).
+        
+        INPUT:
+            - ``search_bound`` --
+            - ``eps`` -- (default: 1e-3)
+
+        OUTPUT:
+            - list
+
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=100)
+            sage: Q.close_points(100)
+            [(6 : 14 : 1)]
+
+        We try some absurdly large values of eps just to illustrate
+        that we may see multiple points within eps of Q::
+        
+            sage: Q.close_points(10, eps=11)
+            [(6 : 14 : 1)]
+            sage: Q.close_points(10, eps=12.5)
+            [(6 : 14 : 1), (2 : 2 : 1)]
+            sage: Q.close_points(10, eps=13.5)
+            [(6 : 14 : 1), (2 : 2 : 1), (0 : 1 : 0)]            
+        """
+        E = self.rational_curve()
+        g = E.gens()
+        if len(g) == 0:
+            P = E(0)
+            search_bound=0
+        else:
+            P = g[0]
+        T = E.torsion_points()
+        v = []
+        for n in range(-search_bound, search_bound+1):
+            Q = n*P
+            for t in T:
+                R = Q + t
+                if abs(R[0] - self[0]) < eps and abs(R[1] - self[1]) < eps:
+                    # record pair (distance, point)
+                    v.append(  ((R[0] - self[0])**2 + (R[1] - self[1])**2, R)  )
+        v.sort()
+        return [R for _, R in v]
+
+    def __getitem__(self, i):
+        """
+        INPUT:
+            - i -- integer (0, 1 or 2)
+
+        OUTPUT:
+            - floating point number (x,y, or z coordinate)
+
+        EXAMPLES::
+        
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=130)
+            sage: Q[0]
+            6.00000000000...
+            sage: Q[1]
+            14.0000000000...
+            sage: Q[2]
+            1.00000000000000
+        """
+        return self._P.__getitem__(i)
+        
+    def __hash__(self):
+        """
+        We also return 0 for the hash.  It's convenient having a hash
+        so that we can use the data structures such as sets in Python
+        with these points, but this is never the bottlekneck in
+        algorithms.  We must have all comparison go through the
+        __cmp__ method.  By making the hash of everything 0, we force
+        hash collisions to always happen and __cmp__ to always be used.
+        
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=100)
+            sage: hash(Q)
+            0
+        """
+        return 0
+    
+    def __add__(self, right):
+        """
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=130)
+            sage: Q+Q
+            (1.61355529131... : 1.184468407... : 1.00000000000000)
+        """
+        if isinstance(right, int) and right == 0:
+            return self
+        return NumericalPoint(self._P + self._P.curve().point(
+            (right._P[0],right._P[1],right._P[2]),check=False), self._eps)
+
+    def __radd__(self, left):
+        """
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=130)
+            sage: 0r+Q
+            (6.00000000000... : 14.0000000000... : 1.00000000000000)
+        """
+        if isinstance(left, int) and left == 0:
+            return self
+        raise NotImplementedError
+    
+    def __rmul__(self, left):
+        """
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=130)
+            sage: 2*Q
+            (1.61355529131... : 1.18446840788... : 1.00000000000000)
+        """
+        return NumericalPoint(left*self._P, self._eps)
+
+    def __mul__(self, right):
+        """
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=130)
+            sage: Q*2
+            (1.61355529131... : 1.18446840788... : 1.00000000000000)
+        """        
+        return NumericalPoint(self._P*right, self._eps)
+    
+    def __cmp__(self, right):
+        """
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=130)
+            sage: S = 2*Q
+            sage: Q
+            (6.00000000000... : 14.0000000000... : 1.00000000000000)
+            sage: S
+            (1.61355529131... : 1.18446840788... : 1.00000000000000)
+            sage: Q == Q
+            True
+            sage: S == S
+            True
+            sage: Q == S
+            False
+
+        Now make a point that is within eps, but clearly not equal, to check
+        cmp in a more subtle case::
+        
+            sage: Q._eps
+            0.0001
+            sage: Z = Q.__class__(Q.curve().point([Q[0]+10*Q._eps, Q[1]+10*Q._eps, 1], check=False), Q._eps)
+            sage: Q == Z
+            False
+            sage: Z = Q.__class__(Q.curve().point([Q[0]+.5*Q._eps, Q[1]+.5*Q._eps, 1], check=False), Q._eps)
+            sage: Q == Z
+            True
+        """        
+        if max([abs(self._P[i]-right._P[i]) for i in range(3)]) < min(self._eps, right._eps):
+            return 0
+        return cmp(self._P, right._P)
+    
+    def __repr__(self):
+        """
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=130)
+            sage: Q.__repr__()
+            '(6.00000000000... : 14.0000000000... : 1.00000000000000)'
+        """
+        return repr(self._P)  
+        
+
+    def identify(self, search=200, eps=1e-5, infinity=1e12):
+        """
+        INPUT:
+            - ``search`` -- (default: 200)
+            - ``eps`` - (default: 1e-5)
+            - ``infinity`` -- (default: 1e12)
+
+        OUTPUT:
+            rational point on elliptic curve
+
+        EXAMPLES::
+
+            sage: Q = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')).numerical_approx(min_imag=1e-3, deg1=130); Q
+            (6.00000000000... : 14.0000000000... : 1.00000000000000)
+            sage: Q.identify()
+            (6 : 14 : 1)
+
+        The index is 6, so searching through multiples only up to 5 of
+        the generator of the Mordell-Weil group fails::
+        
+            sage: Q.identify(search=5)
+            Traceback (most recent call last):
+            ...
+            ValueError: unable to identify rational point
+
+        An example in which the point is 0::
+
+            sage: c = EllipticCurve('57b').chow_heegner_point(EllipticCurve('57a')); c
+            Chow-Heegner point on 57b1 associated to 57a1
+            sage: c.point_exact()
+            (0 : 1 : 0)        
+        """
+        if max(abs(self[0]),abs(self[1])) >= infinity or self._P == 0:
+            return self.rational_curve()(0)
+
+        m = self.close_points(search, eps)
+        if len(m) != 1: 
+            raise ValueError, "unable to identify rational point"
+        else:
+            return m[0]
+
+    
+            
+########################################################################
+# Some helper functions needed for evaluation of the
+# modular parametrization
+########################################################################
+
+def B_bound(ymin, prec):
+    """
+    Return an integer B so that using B terms of the series of a
+    modular parameterization the tail end of the sum is bounded in
+    absolute value by 2**(-prec) for any point with imaginary part at
+    least ymin.
+
+    INPUT:
+        - ``ymin`` -- positive real number; minimum y coordinate
+        - ``prec`` -- positive integer (bits of precision)
+
+    OUTPUT:
+        - integer
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import B_bound
+        sage: B_bound(1e-3,53)
+        6765
+        sage: B_bound(1e-5,53)
+        749700
+        sage: B_bound(1e-5,200)
+        2371372
+
+    We illustrate that the first bound above appears to be enough in
+    one example, but using a smaller bound is not::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import phi_poly
+        sage: phi = phi_poly(EllipticCurve([1..5]), 6765)
+        sage: phi(CDF(e^(2*pi*i*(1+1e-3*I))))
+        0.635422328062 + ...e-14*I
+        sage: phi = phi_poly(EllipticCurve([1..5]), 20000)
+        sage: phi(CDF(e^(2*pi*i*(1+1e-3*I))))
+        0.635422328062 + ...e-14*I
+        sage: phi = phi_poly(EllipticCurve([1..5]), 1000)
+        sage: phi(CDF(e^(2*pi*i*(1+1e-3*I))))
+        0.634984898068 + ...e-14*I
+    """
+    # It is important to use RR instead of RDF in this function
+    # in order to get a larger range of exponents. 
+    y = RR(ymin)
+    epsilon = RR(2)**(-(prec+1))
+    pi = RR.pi()
+    return int((epsilon*(1 - (-2*pi*y).exp())).log() / (-2*pi*y)) + 1
+
+def phi_poly(E, B, base_field=QQ):
+    """
+    Return a polynomial over ``base_field`` that approximates the
+    modular parametrization map associated to E.  This is the degree
+    `B` polynomial `\sum a_n/n T^n`.
+    
+    INPUT:
+        - `E` -- elliptic curve over the rational field
+        - `B` -- a positive integer
+        - ``base_field`` -- (default: QQ); a field
+        
+    OUTPUT:
+        - a polynomial over the base field
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import phi_poly
+        sage: E = EllipticCurve([1..5])
+        sage: phi_poly(E, 10)
+        -3/10*q^10 - 1/3*q^9 - 3/8*q^8 - 1/7*q^7 - 3/5*q^5 - 1/4*q^4 + 1/2*q^2 + q
+        sage: R.<q> = QQ[]
+        sage: sum(E.an(n)/n*q^n for n in [1..10])
+        -3/10*q^10 - 1/3*q^9 - 3/8*q^8 - 1/7*q^7 - 3/5*q^5 - 1/4*q^4 + 1/2*q^2 + q
+        sage: phi_poly(E, 6, RDF)
+        -0.6*q^5 - 0.25*q^4 + 0.5*q^2 + q
+        sage: phi_poly(E, 4, RealField(100))
+        -0.25000000000000000000000000000*q^4 + 0.50000000000000000000000000000*q^2 + q
+    """
+    R = base_field['q']
+    v = E.anlist(B+1)
+    return R([0] + [v[n]/n for n in range(1,B+1)])
+
+def label(E):
+    """
+    Return the Cremona label of E if it is in the installed database,
+    and otherwise just return the string representation of E. This
+    function is used by some of the other printing functions in this
+    module.
+
+    INPUT:
+        - `E` -- elliptic curve over the rational numbers
+    OUTPUT:
+        - string
+
+    EXAMPLES::
+    
+        sage: from sage.schemes.elliptic_curves.chow_heegner import label
+        sage: label(EllipticCurve('11a3'))
+        '11a3'
+        sage: label(EllipticCurve([0,2011]))
+        'Elliptic Curve defined by y^2 = x^3 + 2011 over Rational Field'            
+    """
+    try:
+        return E.cremona_label()
+    except RuntimeError:
+        return str(E)
+
+def check_optimal(E):
+    """
+    If E is in the installed database, verify that E is actually
+    an optimal curve, and do nothing if E is not in the databse.
+    If E is not optimal, raise a ValueError.
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import check_optimal
+        sage: check_optimal(EllipticCurve('11a1'))
+        sage: check_optimal(EllipticCurve('11a2'))
+        Traceback (most recent call last):
+        ...
+        ValueError: curve must be optimal
+
+    At least one of these curves is not optimal, but they have big
+    conductor so they are not in the database::
+
+        sage: E = EllipticCurve([0,-10001,0,10000,0]); E.conductor()
+        266640
+        sage: C = E.isogeny_class()[0]
+        sage: len(C)
+        8
+        sage: [check_optimal(X) for X in C]
+        [None, None, None, None, None, None, None, None]        
+    """
+    try:
+        if not E.cremona_label().endswith('1'):
+            raise ValueError, "curve must be optimal"
+    except RuntimeError:
+        pass
+
+class ModularParametrization(object):
+    """
+    Modular parametrization map designed for the needs of the
+    Chow-Heegner point algorithm.  There is another general modular
+    parametrization class in Sage (in modular_parametrization.py), but
+    it is not suited for this computation (wrong methods and
+    semantics).
+
+    The input curve is assumed optimal.
+    
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+        sage: phi = ModularParametrization(EllipticCurve('37b'))
+        sage: type(phi)
+        <class 'sage.schemes.elliptic_curves.chow_heegner.ModularParametrization'>
+        sage: phi
+        Modular parametrization of 37b1 having degree 2    
+        sage: phi.elliptic_curve()
+        Elliptic Curve defined by y^2 + y = x^3 + x^2 - 23*x - 50 over Rational Field
+        sage: phi.degree()
+        2
+        sage: phi.cusps_over_torsion()
+        {1: [Infinity], 3: [0]}
+        sage: phi.images_of_cusps()
+        {(0, 1): [0], (0, 0): [Infinity]}
+        sage: phi(CDF(1,1))
+        0.00186744489643 - ...e-19*I
+        sage: phi(CDF(2,1))
+        0.00186744489643 - ...e-19*I
+
+    Find points in the fiber over the point 1 mod the period lattice::
+    
+        sage: v = phi.points_in_h(1, 1e-3); v
+        [[-0.3512 + 0.001870*I], [-0.04588 + 0.01936*I]]
+        sage: phi(v[0])
+        1.0 ...
+        sage: phi(v[1])
+        1.0        
+    """
+    def __init__(self, E):
+        """
+        INPUT:
+           - `E` - elliptic curve over QQ assumed to be optimal
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+            sage: ModularParametrization(EllipticCurve('37b1'))
+            Modular parametrization of 37b1 having degree 2
+            
+        The input curve must be optimal::
+        
+            sage: ModularParametrization(EllipticCurve('11a2'))
+            Traceback (most recent call last):
+            ...
+            ValueError: curve must be optimal
+
+        The input must be an elliptic curve over the rational numbers, so this works::
+
+            sage: ModularParametrization(EllipticCurve([1/2,19/4]))
+            Modular parametrization of Elliptic Curve defined by y^2 = x^3 + 1/2*x + 19/4 over Rational Field having degree 127872
+
+        But these don't work::
+            
+            sage: ModularParametrization('37b1')
+            Traceback (most recent call last):
+            ...
+            TypeError: E must be an elliptic curve
+            sage: ModularParametrization(EllipticCurve(GF(7),[3,4]))
+            Traceback (most recent call last):
+            ...
+            TypeError: E must be over QQ
+        """
+        if not is_EllipticCurve(E):
+            raise TypeError, "E must be an elliptic curve"
+        if not is_RationalField(E.base_field()):
+            raise TypeError, "E must be over QQ"
+        check_optimal(E)
+        self._E = E
+        self._label = label(E)
+
+    def elliptic_curve(self):
+        """
+        Return the elliptic curve that this is the modular
+        parametrization of.
+        
+        OUTPUT:
+            - an elliptic curve over the rational numbers
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+            sage: phi = ModularParametrization(EllipticCurve('389a'))
+            sage: phi.elliptic_curve()
+            Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field
+        """
+        return self._E
+        
+    def degree(self):
+        """
+        Return the degree of this modular parametrization.
+        
+        OUTPUT:
+            - positive integer
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+            sage: phi = ModularParametrization(EllipticCurve('389a'))
+            sage: phi.degree()
+            40
+            sage: type(phi.degree())
+            <type 'sage.rings.integer.Integer'>            
+            sage: phi = ModularParametrization(EllipticCurve([19,13]))
+            sage: phi.elliptic_curve().conductor()
+            127996
+            sage: phi.degree()
+            11400        
+        """
+        return self._E.modular_degree()
+
+    def cusps_over_torsion(self):
+        """
+        Return dictionary with keys integers n and values the cusps
+        that map to a torsion point on the elliptic curve of exact
+        order n.  This is computed using modular symbols, so is
+        definitely correct, but will be slow if the conductor is at
+        all large.
+
+        OUTPUT:
+            - dictionary 
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+
+        A well known example -- level 11, where the cusp 0 maps to a 5-torsion point::
+        
+            sage: phi = ModularParametrization(EllipticCurve('11a'))
+            sage: phi.cusps_over_torsion()
+            {1: [Infinity], 5: [0]}
+
+        A higher level example, where there is no nontrivial rational torsion::
+        
+            sage: phi = ModularParametrization(EllipticCurve('57a'))
+            sage: phi.cusps_over_torsion()
+            {1: [0, 1/19, 1/3, Infinity]}
+            sage: phi.elliptic_curve().torsion_order()
+            1
+
+        An example with 2-torsion::
+
+            sage: phi = ModularParametrization(EllipticCurve('57b'))
+            sage: phi.cusps_over_torsion()
+            {1: [Infinity], 2: [0, 1/19, 1/3]}
+            sage: phi.elliptic_curve().torsion_subgroup().invariants()
+            (2, 2)
+        """
+        phi = self._E.modular_symbol_space(0).integral_period_mapping()
+        v = {}
+        for c in Gamma0(self._E.conductor()).cusps():
+            i = phi([c,infinity])
+            d = i.denominator()
+            if v.has_key(d):
+                v[d].append(c)
+            else:
+                v[d] = [c]
+        return v
+
+    def images_of_cusps(self):
+        """
+        Return dictionary with keys elements of a finite module
+        isomorphic to E[d] = (Z/dZ)x(Z/dZ).  The corresponding values
+        for the keys are the cusps that map to that element of E[d].
+        Here d is the exponent of the finite group generated by
+        images of cusps.
+        
+        OUTPUT:
+            - dictionary 
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+            sage: phi = ModularParametrization(EllipticCurve('57b'))
+            sage: phi.images_of_cusps()
+            {(0, 1): [0], (1, 0): [1/19], (0, 0): [Infinity], (1, 1): [1/3]}
+            sage: Z = phi.images_of_cusps(); Z
+            {(0, 1): [0], (1, 0): [1/19], (0, 0): [Infinity], (1, 1): [1/3]}
+            sage: Z.keys()[0].parent()
+            Finitely generated module V/W over Integer Ring with invariants (2, 2)        
+            sage: phi = ModularParametrization(EllipticCurve('11a'))
+            sage: phi.images_of_cusps()
+            {(0, 0): [Infinity], (4, 0): [0]}
+            sage: phi = ModularParametrization(EllipticCurve('57a'))
+            sage: phi.images_of_cusps()
+            {(): [0, 1/19, 1/3, Infinity]}
+        """
+        phi = self._E.modular_symbol_space(0).integral_period_mapping()
+        d = ZZ(1)
+        ims = []
+        for c in Gamma0(self._E.conductor()).cusps():
+            i = phi([c,infinity])
+            d = d.lcm(i.denominator())
+            ims.append((c,i))
+        V = (ZZ**2)
+        Q = V / V.scale(d)
+        v = {}
+        for c, i in ims:
+            P = Q(d*i)
+            if v.has_key(P):
+                v[P].append(c)
+            else:
+                v[P] = [c]
+        return v
+    
+    def __repr__(self):
+        """
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+            sage: ModularParametrization(EllipticCurve('37a')).__repr__()
+            'Modular parametrization of 37a1 having degree 2'           
+        """
+        return "Modular parametrization of %s having degree %s"%(self._label, self.degree())
+
+    def __call__(self, z):
+        """
+        Compute the image of z under this modular parametrization map.
+        We allow z to be either a point in the upper half plane or a
+        list of such points.
+        
+        INPUT:
+            - a complex number or list of complex numbers in the upper half plane
+
+        OUTPUT:
+            - complex number or list of complex numbers
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+            sage: phi = ModularParametrization(EllipticCurve('11a'))
+            sage: phi(CDF(1,1))
+            0.00186395322463 - ...e-19*I
+            sage: phi(ComplexField(100)(1,1))
+            0.0018639532246330691303545022211 - 6.3095154969118369542516994420e-34*I
+            sage: phi([CDF(1,1), CDF(2,1), CDF(2,1/2)])
+            [0.00186395322463..., 0.00186395322463..., 0.0413213515947...]
+
+        A consistency check with the other modular parametrization in Sage::
+
+            sage: phi0 = EllipticCurve('11a').modular_parametrization()
+            sage: P = phi0(CDF(1,1)); P
+            (287826.305812822...: -1.54416950808282e8... : 1.00000000000000)
+            sage: z = phi(CDF(1,1)); z
+            0.00186395322463...
+            sage: E = phi.elliptic_curve()
+            sage: E.elliptic_exponential(z)
+            (287826.305812822...: -1.54416950808282e8... : 1.00000000000000)
+        """
+        if isinstance(z, list):
+            if len(z) == 0:
+                return []
+            z = [(x.z() if isinstance(x,X0NPoint) else x) for x in z]
+            d = max([B_bound(x.imag(), x.prec()) for x in z])
+            is_list = True
+        else:
+            if isinstance(z, X0NPoint):
+                z = z.z()
+            z = [z]
+            d = B_bound(z[0].imag(), z[0].prec())
+            is_list = False
+        f = phi_poly(self._E, d, base_field=z[0].parent())
+        if z[0].prec() > 53:
+            f = ComplexPolynomial(f)
+        else:
+            f = Polynomial_RDF_gsl(f)
+        w = []
+        for x in z:
+            q = h_to_disk(x)
+            w.append(f(q))
+        if not is_list:
+            return w[0]
+        return w
+
+    def _points_in_h_double(self, z, min_imag, max_iter=100, deg1=500):
+        """
+        Find points in upper half plane over double precision z.
+        
+        INPUT:
+            - `z` -- (default: 0.1); floating point number that
+              defines element of period lattice. WARNING: function wil
+              be dramatically slower if z has nonzero imaginary part.
+            - ``min_imag`` -- (default: 1e-4) positive real number; we
+              only find points in the upper half plane with imaginary
+              part at least this
+            - ``max_iter`` -- maximum number of iterations used in
+              newton calls
+            - ``deg1`` -- (default: 500) degree used for first double
+              precision root finding; if too small then some points
+              will be missed.  Reasonable values are between 100 and 3000.
+
+        OUTPUT:
+            - list of CDF elements
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+            sage: phi = ModularParametrization(EllipticCurve('57b'))
+            sage: v = phi._points_in_h_double(z=.1, min_imag=1e-3); v
+            [-0.448258381107 + 0.00603424481535*I, -0.381277139742 + 0.00147982187514*I, -0.303618734588 + 0.0143125900531*I, 0.374289971606*I, 0.303618734588 + 0.0143125900531*I, 0.381277139742 + 0.00147982187514*I, 0.448258381107 + 0.00603424481535*I]
+            sage: [phi(t) for t in v]
+            [0.1..., 0.1..., 0.1..., 0.1, 0.1..., 0.1..., 0.1...]
+        """
+        z = CDF(z)
+        f = phi_poly(self._E, deg1, base_field=CDF) - z
+        try:
+            v = [x for x in cdf_roots_of_rdf_poly(f) if abs(x) < 1]
+        except TypeError:
+            v = [x for x,_ in f.roots() if abs(x) < 1]
+        verbose('Number of double precision roots in upper half plane: %s'%len(v))
+        if len(v) == 0:
+            return []
+
+        # use actual minimum imaginary part found
+        w = [disk_to_h(x).imag() for x in v]
+        w = [x for x in w if x >= min_imag]
+        if len(w) == 0:
+            return []
+        min_imag = min(w)
+        
+        f = phi_poly(self._E, B_bound(min_imag, 53), base_field=CDF) - z
+        t = verbose("deg of refinement poly = %s"%f.degree())
+        w = []
+        if z.imag() == 0:
+            roots = Polynomial_RDF_gsl(f).newton(v, max_iter)
+        else:
+            roots = newton(f, v, max_iter=max_iter)
+                
+        for b,i,err in roots:
+            if abs(b) < 1 and i < max_iter:
+                w.append(b)
+            
+        verbose("found %s double prec roots that refined in %s seconds"%(len(w), cputime(t)))
+        w.sort()
+        w = throw_away_close(w, prec=45)
+
+        # Put points in upper half plane.
+        w = [disk_to_h(z) for z in w]
+        w = [z for z in w if z.imag() >= min_imag]  # 1000 is effectively oo
+        w.sort()
+        return w
+
+    def points_in_h(self, z=CDF(0.1), min_imag=1e-4,
+                    max_iter=25, deg1=500,
+                    max_iter1=100, equiv_prec=None):
+        r"""
+        Return `\Gamma_0(N)`-inequivalent points tau in `X_0(N)` to
+        precision z.prec(), represented as points in the open upper
+        half plane, with tau.imag() >= min_imag; these points map to z
+        via the modular parametrization map.  There is no guarantee at
+        that representatives for all such points have been returned.
+
+        INPUT:
+            - `z` -- (default: 0.1); floating point number that
+              defines element of period lattice. WARNING: Function wil
+              be dramatically slower if z has nonzero imaginary part.
+            - ``min_imag`` -- (default: 1e-4) positive real number; we
+              only find points in the upper half plane with imaginary
+              part at least this
+            - ``max_iter`` -- maximum number of iterations used in
+              newton iteration to refine roots to higher than 53 bits
+              precision, if z has higher than 53 bits precision.
+            - ``deg1`` -- (default: 500) degree used for first double
+              precision root finding; if too small then some points
+              will be missed.  Reasonable values are between 100 and 3000.
+            - ``max_iter1`` -- (default: 100) max number of iterations
+              used in refining initial roots to double precision
+            - ``equiv_prec`` -- (default: prec//3, where prec is
+              precision of z) used in determining Gamma_0(N)
+              equivalence of points
+            
+        OUTPUT:
+            - list of inequivalent numerical points in the upper half
+              plane that define elements of the modular curve `X_0(N)`
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ModularParametrization
+            sage: phi = ModularParametrization(EllipticCurve('37b'))
+
+        Defaults to points over 0.1::
+        
+            sage: v = phi.points_in_h(deg1=100); v
+            [[-0.3441 + 0.008841*I], [-0.2982 + 0.001291*I]]
+            sage: phi(v[0]), phi(v[1])
+            (0.1 ..., 0.1 ...)
+
+        Compute points over 1::
+        
+            sage: v = phi.points_in_h(RDF(1), deg1=100); v
+            [[-0.3512 + 0.001870*I], [-0.1683 + 0.001018*I]]
+            sage: phi(v[0]), phi(v[1])
+            (1.0 ..., 1.0 ...)
+
+        Points over I::
+        
+            sage: v = phi.points_in_h(CDF(0,1), deg1=100); v    # long time
+            [[-0.3443 + 0.0008692*I], [0.1500 + 0.007604*I]]
+            sage: phi(v[0]), phi(v[1])                          # long time
+            (-1.02140518266e-14 + 1.0*I, 5.55111512313e-16 + 1.0*I)        
+
+        To higher precision::
+        
+            sage: v = phi.points_in_h(RealField(100)(1), min_imag=1e-3); v
+            [[-0.35115510977014 + 0.0018701266234958*I], [-0.045882897517034 + 0.019362756466571*I]]
+            sage: phi(v[0])
+            1.0000000000000000000000000000 + 1.9721522630525295135293214132e-29*I
+            sage: phi(v[1])
+            1.0000000000000000000000000000 + 2.7610131682735413189410499785e-30*I
+
+        Consider points with smaller imaginary parts::
+        
+            sage: phi.points_in_h(RDF(1), min_imag=1e-4)
+            [[-0.3574 + 0.0004481*I], [-0.3512 + 0.001870*I]]
+
+        Change the degree of the initial polynomial approximation to
+        the modular parametrization map::
+        
+            sage: phi.points_in_h(RDF(1), deg1=100, min_imag=1e-3)
+            [[-0.3512 + 0.001870*I], [-0.04588 + 0.01936*I]]
+
+        Use a different bound on Newton iterations::
+        
+            sage: phi.points_in_h(RDF(1), max_iter1=10, min_imag=1e-3)
+            [[-0.3512 + 0.001870*I], [-0.04588 + 0.01936*I]]
+
+        Consider points as equivalent if they are equivalent to very
+        low precision (silly example)::
+        
+            sage: phi.points_in_h(RDF(1), equiv_prec=2, min_imag=1e-3)
+            [[-0.38 + 0.0020*I], [-0.047 + 0.016*I]]
+
+        Consider points equivalent only if equivalent to high
+        precision, which will result in falsely considering points as
+        inequivalent::
+
+            sage: len(phi.points_in_h(RDF(1), equiv_prec=50, min_imag=1e-3))
+            10
+            sage: len(phi.points_in_h(RDF(1), equiv_prec=40, min_imag=1e-3))
+            2        
+        """
+        C = parent(z)
+        if not (C == CDF or is_ComplexField(C)):
+            try:
+                prec = z.prec()
+            except AttributeError:
+                prec = 53
+            C = CDF if prec==53 else ComplexField(prec)
+            z = C(z)
+
+        N = self._E.conductor()
+
+        v = self._points_in_h_double(z, min_imag=min_imag, max_iter=max_iter1, deg1=deg1)
+        if len(v) == 0:
+            return []
+            
+        prec = z.prec()
+        if equiv_prec is None:
+            equiv_prec = prec//3
+        if prec <= 53:
+            # double precision already enough
+            ans = list(set([X0NPoint(C(x),N,prec=equiv_prec) for x in v]))
+            ans.sort()
+            return ans
+
+        m_E = self.degree()
+        
+        # refine to higher precision, and keep only good roots
+        verbose("Number of double precision roots to refine via Newton iteration: %s"%len(v))
+        t = cputime()
+        f = phi_poly(self._E, B_bound(min_imag, prec), base_field=C) - z
+        
+        # We try m_E points at a time, since the newton step below is expensive.
+        w0 = []; w = []
+        while len(w) < m_E:
+            for b,i,err in newton(f, [h_to_disk(C(a)) for a in v[:m_E]],
+                                            max_iter, max_err=C(2)**(2-prec)):
+                if abs(b) < 1 and i < max_iter:
+                    w0.append(b)
+            v = v[m_E:]
+            w0 = throw_away_close(w0, prec=prec-10)
+
+            # transform and take distinct X0 points in upper half plane.
+            w = [disk_to_h(z) for z in w0]
+            w = [z for z in w if z.imag() >= min_imag and z.imag() <= 1]  # above 1 --> is point at oo
+            w = [X0NPoint(z, N, prec=prec//2) for z in w]
+            w = list(set(w))
+            
+        verbose("found %s roots to prec %s that refined in %s seconds"%(len(w), prec, cputime(t)))
+        w.sort()
+        return w
+
+
+class ChowHeegnerPoint(object):
+    """
+    A Chow-Heegner point associated to an ordered pair of optimal
+    elliptic curves of the same conductor.
+
+    EXAMPLES::
+
+        sage: P = EllipticCurve('57a').chow_heegner_point(EllipticCurve('57b')); P
+        Chow-Heegner point on 57a1 associated to 57b1
+        sage: P.numerical_approx()
+        (1.44444444444440...: -1.03703703703... : 1.00000000000000)
+        sage: P.point_exact()
+        (13/9 : -28/27 : 1)
+
+    You can recover the two curves used to define the point::
+
+        sage: P.curves()
+        (Elliptic Curve defined by y^2 + y = x^3 - x^2 - 2*x + 2 over Rational Field, Elliptic Curve defined by y^2 + x*y + y = x^3 - 7*x + 5 over Rational Field)
+    """
+    def __init__(self, E, F):
+        """
+        Initialize Chow-Heegner point associated to a pair of curves
+        of the same conductor.
+
+        INPUT:
+            - `E`, `F` -- optimal elliptic curve over the rational
+              numbers, or Cremona labels for elliptic curves
+
+        EXAMPLES::
+
+            sage: E = EllipticCurve('37a'); F = EllipticCurve('37b')
+            sage: E.chow_heegner_point(F)
+            Chow-Heegner point on 37a1 associated to 37b1
+            
+            sage: from sage.schemes.elliptic_curves.chow_heegner import ChowHeegnerPoint
+            sage: ChowHeegnerPoint(E, F)
+            Chow-Heegner point on 37a1 associated to 37b1
+            sage: ChowHeegnerPoint(F, E)
+            Chow-Heegner point on 37b1 associated to 37a1
+
+        We allow E and F to be Cremona labels::
+
+            sage: ChowHeegnerPoint('37a', '37b')
+            Chow-Heegner point on 37a1 associated to 37b1            
+
+        The two curves must have the same conductor.  This is an
+        implementation issue, not a theoretical issue, which is why a
+        NotImplementedError is raised::
+        
+            sage: ChowHeegnerPoint(E, EllipticCurve('57b'))
+            Traceback (most recent call last):
+            ...
+            NotImplementedError: E and F must currently have the same conductor
+
+        The curves must also be optimal::
+        
+            sage: ChowHeegnerPoint(EllipticCurve('37a1'), EllipticCurve('37b2'))
+            Traceback (most recent call last):
+            ...
+            ValueError: curve must be optimal
+            sage: ChowHeegnerPoint(EllipticCurve('37b2'), EllipticCurve('37a1'))
+            Traceback (most recent call last):
+            ...
+            ValueError: curve must be optimal
+
+        They must be distinct and non-isogenous::
+
+            sage: ChowHeegnerPoint(EllipticCurve('11a1'), EllipticCurve('11a1'))
+            Traceback (most recent call last):
+            ...
+            ValueError: E and F must not be isomorphic        
+
+        The curves must be over the rational numbers::
+
+            sage: E = EllipticCurve(QuadraticField(-1),[1..5])
+            sage: ChowHeegnerPoint(E, E)
+            Traceback (most recent call last):
+            ...
+            ValueError: E and F must be elliptic curves over QQ        
+        """
+        if isinstance(E, str): E = EllipticCurve(E)
+        if isinstance(F, str): F = EllipticCurve(F)
+
+        if not is_RationalField(E.base_ring()) or not is_RationalField(F.base_ring()):
+            raise ValueError, "E and F must be elliptic curves over QQ"
+        if E.conductor() != F.conductor():
+            raise NotImplementedError, "E and F must currently have the same conductor"
+        if E.is_isomorphic(F):
+            raise ValueError, "E and F must not be isomorphic"
+        check_optimal(E)
+        check_optimal(F)
+        self._E = E
+        self._F = F
+        self._fE = ModularParametrization(E)
+        self._fF = ModularParametrization(F)
+
+    def __cmp__(self, right):
+        """
+        We compare the ordered pair of underlying elliptic curves.
+        
+        EXAMPLES::
+
+            sage: P = EllipticCurve('57a').chow_heegner_point(EllipticCurve('57b'))
+            sage: P == P
+            True
+            sage: Q = EllipticCurve('57b').chow_heegner_point(EllipticCurve('57a'))
+            sage: P == Q
+            False
+            sage: P < Q
+            True
+            sage: Q < P
+            False
+        """
+        assert isinstance(right, ChowHeegnerPoint)
+        return cmp((self._E, self._F), (right._E, right._F))
+        
+    def __repr__(self):
+        """
+        EXAMPLES::
+
+            sage: P = EllipticCurve('446a').chow_heegner_point(EllipticCurve('446b'))
+            sage: P.__repr__()
+            'Chow-Heegner point on 446a1 associated to 446b1'
+        """
+        return "Chow-Heegner point on %s associated to %s"%(label(self._E), label(self._F))
+
+    def curves(self):
+        """
+        Return the two curves that this Chow-Heegner point is associated to.
+
+        OUTPUT:
+            2-tuple of elliptic curves over QQ
+
+        EXAMPLES::
+
+            sage: P = EllipticCurve('446a').chow_heegner_point(EllipticCurve('446b'))
+            sage: E, F = P.curves()
+            sage: E.cremona_label(), F.cremona_label()
+            ('446a1', '446b1')            
+        """
+        return self._E, self._F
+
+    def parametrizations(self):
+        """
+        Return the modular parametrization maps associated to E and F.
+
+        OUTPUT:
+            2-tuple of modular parametrization maps
+
+        EXAMPLES::
+        
+            sage: P = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b'))
+            sage: P.parametrizations()
+            (Modular parametrization of 37a1 having degree 2, Modular parametrization of 37b1 having degree 2)
+        """
+        return self._fE, self._fF
+
+    def points_over_F(self, *args, **kwds):
+        """
+        Return some points on `X_0(N)` over a given real point on F
+        represented as a real number modulo the period lattice.
+        
+        The input and output options are the same as those for the
+        method ``points_in_h`` of the modular parametrization maps.
+        Use self.parametrizations()[1] to get one of the maps, and
+        look at the docstring.
+
+        EXAMPLES::
+
+            sage: P = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b'))
+            sage: v = P.points_over_F(1/4, deg1=100); v
+            [[-0.3465 + 0.008016*I], [-0.2989 + 0.001326*I]]
+            sage: phi = P.parametrizations()[1]
+            sage: phi(v[0]), phi(v[1])
+            (0.25..., 0.25...)
+
+        Here's an example of getting the points, but to higher precision::
+
+            sage: v = P.points_over_F(RealField(100)(1/4), deg1=100); v  # long time
+            [[-0.34645302134160 + 0.0080165180402406*I], [-0.29890732134688 + 0.0013263630385348*I]]
+            sage: phi(v[0]), phi(v[1])      # long time
+            (0.25000000000000000000000000000 + 3.2540512340366736973233803318e-30*I, 0.25000000000000000000000000004 + 1.2621774483536188886587657045e-29*I)            
+        """
+        return self._fF.points_in_h(*args, **kwds)
+
+    def numerical_approx(self, *args, **kwds):
+        """
+        Return a numerical approximation to this Chow-Heegner point.
+
+        This function takes exactly the same inputs as the compute
+        method, so see the docstring for that method.
+        
+        EXAMPLES::
+
+            sage: P = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b'))
+            sage: P.numerical_approx(deg1=130)
+            (6.00000000000... : 14.0000000000... : 1.00000000000000)
+            sage: P.numerical_approx(60, deg1=130)
+            (6.00000000000... : 14.000000000000... : 1.0000000000000000)
+            sage: P = EllipticCurve('37b').chow_heegner_point(EllipticCurve('37a'))
+            sage: P.numerical_approx(deg1=100)
+            (8.00000000000... : 18.0000000000... : 1.00000000000000)
+        """
+        P, _, _ = self.compute(*args, **kwds)
+        if P is not None:
+            return P
+        else:
+            raise RuntimeError, "failed to compute"
+
+    @cached_method
+    def point_exact(self, search=100, eps=1e-5, infinity=1e12, **kwds):
+        """
+        Return one of the best exact approximations to this point that
+        is a bounded multiple of the generators, and has x and y
+        coordinate that is at least within eps of the numerical
+        approximation of this point, or the point infinity (see
+        below).
+
+        INPUT:
+            - ``search`` -- (default: 100) search through all points
+              of the form t + sum n*g, where t is torsion, g is a
+              generator, and abs(n) <= search.
+            - ``eps`` -- (default: 1e-5) a small float; x and y
+              coordinates must be at least this close
+            - ``infinity`` -- (default: 1e12) a large float; if either
+              x or y coordinate of numerical approximation is at least
+              this big, then we just declare this the point at
+              infinity, and do not do a search.
+            - ``**kwds`` -- all other keyword arguments are passed to
+              the ``numerical_approx`` method.
+        
+        EXAMPLES::
+        
+            sage: P = EllipticCurve('99a').chow_heegner_point(EllipticCurve('99b'))
+            sage: P.numerical_approx()
+            (1.64062499999... : -1.75195312499... : 1.00000000000000)
+            sage: P.point_exact()
+            (105/64 : -897/512 : 1)
+            sage: P.index()
+            4
+        """
+        P = self.numerical_approx(**kwds)
+        return P.identify(search=search, eps=eps, infinity=infinity)
+
+    def index(self, *args, **kwds):
+        """
+        Index of this Chow-Heegner point in the Mordell-Weil group
+        modulo torsion.
+
+        INPUT:
+            - exactly the same as for the point_exact method
+
+        OUTPUT:
+            - Integer
+
+        EXAMPLES::
+
+            sage: P = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b'))
+            sage: P.index(min_imag=1e-3, deg1=100)
+            6       
+        """
+        P = self.point_exact(*args, **kwds)
+        h = P.height()
+        E = self._E
+        return ZZ(int((h/E.regulator()).sqrt().round()))
+
+    @cached_method
+    def compute(self, prec=53, z='0.1',
+                equiv_prec=None, deg1=500, min_imag=1e-4,
+                fiber=None, number_to_stabilize=6):
+        """
+        INPUT:
+            - ``prec`` -- (default: 53) precision of numerical
+              computations (should be at least 53)
+            - `z` -- (default: 0.1) base point representative
+            - ``equiv_prec`` -- (default: prec//3) precision for
+              checking Gamma0(N) equivalence
+            - ``deg1`` -- (default: 500) degree used for first double
+              precision root finding; if too small then some points
+              will be missed.  Reasonable values are between 100 and 3000.
+            - ``min_imag`` -- (default: 1e-4) positive real number; we
+              only find points in the upper half plane with imaginary
+              part at least this
+            - ``fiber`` -- (default: None); if given as a list, then
+              we assume that the points in this list were the output
+              from a previous run of the compute command, and start
+              with this list, instead of starting from scratch
+            - ``number_to_stabilize`` -- (default: 6); if after this
+              many attempts (using varying equivalent base points) we
+              find no further points in fiber, then this function
+              terminates; if not enough points were found, the output
+              point P is None.
+
+        OUTPUT:
+          The 3-tuple with entries:
+            - ``P`` -- None, or the numerically computed Chow-Heegner
+              point if we found enough points in the fiber
+            - ``fiber`` -- the inequivalent points we found in the fiber
+            - ``base_points`` -- the real numbers that define points
+              on F that we computed the fiber over; these points are
+              all equivalent to z modulo the period lattice
+
+        EXAMPLES::
+
+            sage: P = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b'))
+            sage: m, fiber, base_points = P.compute(deg1=130, min_imag=1e-3)
+            sage: m
+            (6.00000000000... : 14.0000000000... : 1.00000000000000)
+            sage: fiber
+            [[-0.3441 + 0.008841*I], [-0.2982 + 0.001291*I]]
+            sage: base_points
+            [0.1]
+
+        We compute (and get the same answer) using a complex base
+        point, which gives us increased confidence in our result::
+
+            sage: P.compute(z=CDF(1,1), min_imag=1e-3, deg1=130)
+            ((6.00000000000... : 14.0000000000... : 1.00000000000000), [[-0.04423 + 0.001498*I], [0.08721 + 0.001363*I]], [1.0 + 1.0*I])
+        """
+        if prec == 53:
+            z = CDF(z)
+        else:
+            z = ComplexField(prec)(z)
+
+        if equiv_prec is None:
+            equiv_prec = z.prec()//3
+
+        if fiber is None:
+            fiber = []
+        else:
+            fiber = list(fiber)
+
+        base_points = [z]
+        mF = self._fF.degree()
+        verbose("Modular degree of F (target fiber size) = %s"%mF)
+        target = mF
+        Omega = self._F.period_lattice().basis(z.prec())[0]
+        n = 0
+        if z == 0:
+            # reduce target by number of cusps that map to 0
+            C = self._fF.cusps_over_torsion()[1]
+            target -= len(C)
+            verbose("Reducing target by %s cusps to %s (TODO *** result may be off by torsion! *** )"%(len(C), target))
+
+        same_in_a_row = 0
+        while len(fiber) < target:
+            b = len(fiber)
+            tm = verbose("** deg1 = %s, min_imag = %s, equiv_prec = %s, len(fiber) = %s, target = %s"%(deg1, min_imag, equiv_prec, b, target))
+            for t in self.points_over_F(z, min_imag=min_imag, deg1=deg1, equiv_prec=equiv_prec):
+                fiber.append(t)
+            fiber = list(set(fiber))
+            verbose("** Found %s new points in %s seconds"%(len(fiber)-b, cputime(tm)))
+            if len(fiber) == b:
+                same_in_a_row += 1
+                if same_in_a_row >= number_to_stabilize:
+                    verbose("*"*80)
+                    verbose("** ERROR: same result %s times in a row, so 'stabilized' (GIVING UP!)"%same_in_a_row)
+                    verbose("*"*80)
+                    stabilize = True
+                    break
+            else:
+                same_in_a_row = 0
+            if len(fiber) < target:
+                verbose('*'*80)
+                # change base point
+                n += 1
+                z += ((-1)**(n+1)) * n*Omega
+                base_points.append(z)
+                verbose("z (=%s) |--> %s"%(base_points[-1], z))
+            elif len(fiber) == target:
+                verbose('+'*80)
+                verbose("*** Found all %s points in the fiber ***"%target)
+            else:
+                verbose('-'*80)
+                raise RuntimeError, "Found too many points (%s > %s) -- try (good) increasing precision of z (now=%s) or (bad) *decreasing* equiv_prec (now=%s)"%(
+                    len(fiber),target,z.prec(),equiv_prec)
+
+        if len(fiber) == target:
+            verbose("Mapping points on modular curve to E...")
+            t = cputime()
+            m = self._fE(fiber)
+            verbose("Mapped to E in %s seconds"%cputime(t))
+            s = sum(m)
+            if isinstance(s, int) and s == 0:
+                P = NumericalPoint(self._E(0), 1e-4)
+            else:
+                P = NumericalPoint(self._E.elliptic_exponential(s), 1e-4)
+        else:
+            P = None
+            
+        return P, fiber, base_points
+
+
diff --git a/sage/schemes/elliptic_curves/chow_heegner_fast.pyx b/sage/schemes/elliptic_curves/chow_heegner_fast.pyx
new file mode 100644
--- /dev/null
+++ b/sage/schemes/elliptic_curves/chow_heegner_fast.pyx
@@ -0,0 +1,533 @@
+##############################################################################
+#       Copyright (C) 2011 William Stein <wstein@gmail.com>
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#    This code is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#    General Public License for more details.
+#
+#  The full text of the GPL is available at:
+#
+#                  http://www.gnu.org/licenses/
+##############################################################################
+"""
+Chow-Heegner Points (fast Cython code)
+"""
+
+##############################################################################
+# Implementation Note: one could make a case that most of the
+# functions in the file could be moved to other places in the Sage
+# library where they might speed up all code.  We do not plan to do
+# that for the first version of this patch, since this code could also
+# slow down code in low degree, and may have worrisome numerical
+# rounding implications for other code.  By keeping it here, we keep
+# this code as simple as possible as well, since we don't have to
+# optimize for general cases that aren't need for our application.
+#
+# The right way to do this is to make a completely new complete
+# RDF['x'] class that uses GSL.  For example, for an instance of the
+# class Polynomial_RDF_gsl of a polynomial of degree 1000, evaluation
+# is over 100 times faster than for the same element of RDF['x']!
+# So this has to happen.  However, it's a hell of a lot more work
+# than implementing Polynomial_RDF_gsl below.
+##############################################################################
+
+include 'sage/gsl/gsl_complex.pxi'
+include 'sage/gsl/gsl_poly.pxi'
+
+cdef extern from "gsl/gsl_poly.h":
+    gsl_complex gsl_poly_complex_eval (double c[], int n, gsl_complex z)
+
+from sage.rings.all import CDF
+
+include 'sage/ext/interrupt.pxi'
+include 'sage/ext/stdsage.pxi'
+
+from sage.rings.all import RR
+
+from sage.stats.intlist cimport IntList
+
+def required_series_prec(y, prec):
+    """
+    Return integer B so that using B terms of the series of a modular
+    parameterization the tail end of the sum is less than 2**(-prec)
+    in absolute value for any point z with Im(z)>=ymin.
+
+    INPUT:
+        - ``ymin`` -- positive real number; minimum y coordinate
+        - ``prec`` -- positive integer (bits of precision)
+
+    OUTPUT:
+        - Python int
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner_fast import required_series_prec
+        sage: required_series_prec(1e-4, 53)
+        71306
+        sage: required_series_prec(1e-5, 53)
+        749700
+
+    The following means that for any elliptic curve and any point z in
+    the upper half plane with imaginary part at least 1e-4, the tail
+    end of the modular parametrization evaluated at z is less than
+    2^(-200) in absolute value::
+    
+        sage: required_series_prec(1e-4, 200)
+        233473        
+    """
+    y = RR(y)
+    epsilon = RR(2)**(-(prec+1))
+    pi = RR.pi()
+    return int((epsilon*(1 - (-2*pi*y).exp())).log() / (-2*pi*y)) + 1
+
+###############################################################
+# Cython code to efficiently evalute a polynomial with
+# ComplexField(prec) coefficients very efficiently.
+# Below we have functions for * and + of Cython ComplexNumber
+# objects.  This code is basically same as code in the
+# complex_number.pyx file; however, it allows for
+# mutating the output argument in place without having
+# to create a new ComplexNumber argument, which is something
+# the code in complex_number.pyx simply does not allow.
+# This results in a huge speedup.   The "right" way to do this
+# would probably be to completely refactor complex_number.pyx
+# so that all arithmetic functions there call functions
+# like the ones below.  However, that would be a lot more work
+# for a questionable payback.
+###############################################################
+
+from sage.rings.complex_number cimport (ComplexNumber,
+     mpfr_t, mpfr_init2, mpfr_mul, mpfr_sub, mpfr_add, mpfr_clear, GMP_RNDN)
+
+cdef int ComplexNumber_mul(ComplexNumber x, ComplexNumber left, ComplexNumber right):
+    """
+    Multiply two ComplexNumber objects.
+    """
+    cdef mpfr_t t0, t1
+    mpfr_init2(t0, left._prec)
+    mpfr_init2(t1, left._prec)
+    mpfr_mul(t0, left.__re, right.__re,  GMP_RNDN)
+    mpfr_mul(t1, left.__im, right.__im,  GMP_RNDN)
+    mpfr_sub(x.__re, t0, t1,  GMP_RNDN)
+    mpfr_mul(t0, left.__re, right.__im,  GMP_RNDN)
+    mpfr_mul(t1, left.__im, right.__re,  GMP_RNDN)
+    mpfr_add(x.__im, t0, t1,  GMP_RNDN)
+    mpfr_clear(t0)
+    mpfr_clear(t1)
+
+cdef int ComplexNumber_add(ComplexNumber x, ComplexNumber left, ComplexNumber right):
+    """
+    Add two ComplexNumber objects.
+    """
+    mpfr_add(x.__re, left.__re, right.__re,  GMP_RNDN)
+    mpfr_add(x.__im, left.__im, right.__im,  GMP_RNDN)
+
+cdef class ComplexPolynomial:
+    """
+    A polynomial with floating point complex number entries that is
+    optimized for fast evaluation when the degree is relatively large.
+
+    TESTS::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner_fast import ComplexPolynomial
+        sage: f = ComplexPolynomial(ComplexField(100)['x']([1,2]))
+        sage: TestSuite(f).run()
+    """
+    cdef list a
+    cdef readonly object f
+    def __init__(self, f):
+        """
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import ComplexPolynomial
+            sage: f = ComplexPolynomial(ComplexField(100)['x']([1,2])); f
+            2.0000000000000000000000000000*x + 1.0000000000000000000000000000
+            sage: type(f)
+            <type 'sage.schemes.elliptic_curves.chow_heegner_fast.ComplexPolynomial'>        
+        """
+        self.a = f.list()
+        self.f = f
+
+    def __repr__(self):
+        """
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import ComplexPolynomial
+            sage: f = ComplexPolynomial(ComplexField(100)['x']([1,2])); f.__repr__()
+            '2.0000000000000000000000000000*x + 1.0000000000000000000000000000'
+        """
+        return repr(self.f)
+
+    def __cmp__(self, right):
+        """
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import ComplexPolynomial
+            sage: f = ComplexPolynomial(ComplexField(100)['x']([1,2])); g = ComplexPolynomial(ComplexField(100)['x']([1,3]))
+            sage: cmp(f,f)
+            0
+            sage: cmp(f,g)
+            -1
+            sage: cmp(g,f)
+            1
+        """
+        return cmp(self.f, right.f)
+
+    def __reduce__(self):
+        """
+        Used in pickling.
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import ComplexPolynomial
+            sage: ComplexPolynomial(ComplexField(100)['x']([1,2])).__reduce__()
+            (<type 'sage.schemes.elliptic_curves.chow_heegner_fast.ComplexPolynomial'>, (2.0000000000000000000000000000*x + 1.0000000000000000000000000000,))        
+        """
+        return ComplexPolynomial, (self.f,)
+
+    def __call__(self, z0):
+        """
+        Evaluate this polynomial at z0.
+
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import ComplexPolynomial
+            sage: f = ComplexField(100)['x']([1..20]); g = ComplexPolynomial(f)
+            sage: f(1)
+            210.00000000000000000000000000
+            sage: g(1)
+            210.00000000000000000000000000        
+        """
+        cdef list a = self.a
+        C = a[0].parent()
+        cdef ComplexNumber z = C(z0)
+            
+        # Use Horner's rule (see http://en.wikipedia.org/wiki/Horner_scheme)
+        cdef Py_ssize_t n = len(a)-1
+        cdef ComplexNumber t = C(0), b = C(a[n].real(), a[n].imag())  # b must be a new copy -- do not do "b = a[n]" here or you'll get a huge bug!
+        
+        while n >= 1:
+            n -= 1
+            # Fast version of: b = a[n] + b*z
+            ComplexNumber_mul(t, b, z)      # t = b*z
+            ComplexNumber_add(b, a[n], t)   # b = a[n] + t
+        return b
+
+    def degree(self):
+        """
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import ComplexPolynomial
+            sage: ComplexPolynomial(ComplexField(100)['x']([1..10])).degree()
+            9
+        """
+        return self.f.degree()
+
+
+from sage.rings.complex_double cimport ComplexDoubleElement
+
+cdef class Polynomial_RDF_gsl:
+    """
+    A polynomial with RDF (real double) coefficients, which can
+    compute roots and do Newton iteration via fast code in the GSL
+    library.
+
+    TESTS::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+        sage: s = Polynomial_RDF_gsl(RDF['x']([1..3]))
+        sage: TestSuite(s).run()    
+    """
+    cdef double *c, *c_d
+    cdef readonly object f
+    cdef int n, n_d
+    
+    def __cinit__(self, f):
+        """
+        EXAMPLES::
+
+        Make an object of type Polynomial_RDF_gsl::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: s = Polynomial_RDF_gsl(RDF['x']([1..3])); type(s)
+            <type 'sage.schemes.elliptic_curves.chow_heegner_fast.Polynomial_RDF_gsl'>
+            sage: s.f
+            3.0*x^2 + 2.0*x + 1.0
+
+        Check that the f attribute is read only::
+        
+            sage: s.f = 0
+            Traceback (most recent call last):
+            ...
+            AttributeError: attribute 'f' of 'sage.schemes.elliptic_curves.chow_heegner_fast.Polynomial_RDF_gsl' objects is not writable        
+        """
+        self.c = NULL
+        self.c_d = NULL
+        self.f = f
+
+    def __reduce__(self):
+        """
+        Used in pickling.
+        
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: s = Polynomial_RDF_gsl(RDF['x']([1..3]))
+            sage: s.__reduce__()
+            (<type 'sage.schemes.elliptic_curves.chow_heegner_fast.Polynomial_RDF_gsl'>, (3.0*x^2 + 2.0*x + 1.0,))
+        """
+        return Polynomial_RDF_gsl, (self.f, )
+
+    def __cmp__(self, right):
+        """
+        Compares underlying polynomials.
+        
+        EXAMPLES::
+
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: s = Polynomial_RDF_gsl(RDF['x']([1..3])); t = Polynomial_RDF_gsl(RDF['x']([3,2,1]))
+            sage: s == s
+            True
+            sage: s == t
+            False
+            sage: cmp(s,t)
+            1
+            sage: cmp(t,s)
+            -1
+            sage: cmp(t.f,s.f)
+            -1        
+        """
+        return cmp(self.f, right.f)
+    
+    def __init__(self, f):
+        """
+        EXAMPLES::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: s = Polynomial_RDF_gsl(RDF['x']([1..5])); s
+            5.0*x^4 + 4.0*x^3 + 3.0*x^2 + 2.0*x + 1.0
+            sage: type(s)
+            <type 'sage.schemes.elliptic_curves.chow_heegner_fast.Polynomial_RDF_gsl'>
+        """
+        self.n = f.degree() + 1
+        self.c = <double*> sage_malloc(sizeof(double)*self.n)
+        if not self.c:
+            self.c = NULL
+            raise MemoryError
+        cdef list v = f.list()
+        cdef Py_ssize_t i        
+        for i in range(self.n):
+            self.c[i] = v[i]
+
+    def __repr__(self):
+        """
+        EXAMPLES::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: Polynomial_RDF_gsl(RDF['x']([-2.5,3,-1])).__repr__()
+            '-x^2 + 3.0*x - 2.5'
+        """
+        return self.f.__repr__()
+
+    def __dealloc__(self):
+        if self.c: sage_free(self.c)
+        if self.c_d: sage_free(self.c_d)        
+
+    def __call__(self, x):
+        """
+        EXAMPLES::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: s = Polynomial_RDF_gsl(RDF['x']([1..100]))
+            sage: s(1)
+            5050.0
+            sage: s.f(1)
+            5050.0            
+        """
+        cdef ComplexDoubleElement w, z
+        cdef gsl_complex a
+        if isinstance(x, ComplexDoubleElement):
+            z = x
+        else:
+            z = CDF(x)
+        a = gsl_poly_complex_eval(self.c, self.n, z._complex)
+        w = z._new_c(a)
+        return w
+
+    def _init_deriv(self):
+        """
+        Initially derivative attribute, which is used in the __call__ method.
+        
+        EXAMPLES::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: s = Polynomial_RDF_gsl(RDF['x']([1..5]))
+            sage: s._init_deriv()
+        """
+        if self.c_d: return
+        f_d = self.f.derivative()
+        self.n_d = f_d.degree()+1
+        self.c_d = <double*> sage_malloc(sizeof(double)*self.n_d)
+        cdef list v = f_d.list()
+        cdef Py_ssize_t i
+        for i in range(self.n_d):
+            self.c_d[i] = v[i]
+
+    def roots(self):
+        """
+        EXAMPLES::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: s = Polynomial_RDF_gsl(RDF['x']([1..3]))
+            sage: s
+            3.0*x^2 + 2.0*x + 1.0
+            sage: s.roots()
+            [-0.333333333333 - 0.471404520791*I, -0.333333333333 + 0.471404520791*I]
+            sage: s.f.roots(CDF, multiplicities=False)
+            [-0.333333333333 - 0.471404520791*I, -0.333333333333 + 0.471404520791*I]
+
+        A higher degree example::
+        
+            sage: s = Polynomial_RDF_gsl(RDF['x']([1..400]))
+            sage: v = s.roots()
+            sage: w = s.f.roots(CDF, multiplicities=False)
+            sage: max([abs(v[i]-w[i]) for i in range(len(v))])
+            3...e-13
+        """
+        return cdf_roots_of_rdf_poly(self.f)
+
+    def degree(self):
+        """
+        EXAMPLES::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: Polynomial_RDF_gsl(RDF['x']([1..10])).degree()
+            9
+        """
+        return self.f.degree()
+
+    def newton(self, x, int max_iter=1000, double max_err=1e-14):
+        """
+        Refine approximate double precision roots x using Newton's
+        method.  Return list of triples consisting of the refined
+        approximation, number of iterations and the error as output by
+        GSL.
+
+        EXAMPLES::
+        
+            sage: from sage.schemes.elliptic_curves.chow_heegner_fast import Polynomial_RDF_gsl
+            sage: s = Polynomial_RDF_gsl(RDF['x']([1..4])); s
+            4.0*x^3 + 3.0*x^2 + 2.0*x + 1.0
+            sage: s.f.roots(CDF, multiplicities=False)
+            [-0.605829586188, -0.0720852069059 - 0.638326735148*I, -0.0720852069059 + 0.638326735148*I]
+            sage: s.newton(0)
+            [(-0.605829586188, 7, 0.0)]
+
+        The above used 7 iterations; let's restrict to at most 4 iterations::
+        
+            sage: s.newton(0, 4)
+            [(-0.605830058052, 4, 0.00055292067107393095)]
+
+        A very small max_err::
+
+            sage: s.newton(0, max_err=0.1)
+            [(-0.606382978723, 3, 0.018617021276595702)]        
+
+        Start at a complex approximate root::
+        
+            sage: s.newton(-.6*I)
+            [(-0.0720852069059 - 0.638326735148*I, 6, 1.3877787807814457e-17)]
+
+        Make x a list of approximate roots::
+            sage: s.newton([0, -.6*I])
+            [(-0.605829586188, 7, 0.0), (-0.0720852069059 - 0.638326735148*I, 6, 1.3877787807814457e-17)]
+        """
+        self._init_deriv()
+        cdef int i
+        cdef gsl_complex root, last_root
+        cdef double err
+        if not isinstance(x, list):
+            v = [x]
+        else:
+            v = x
+
+        ans = []
+        cdef ComplexDoubleElement z
+        for x in v:
+            z=CDF(x)
+            GSL_SET_COMPLEX(&root, z._complex.dat[0], z._complex.dat[1])
+            GSL_SET_COMPLEX(&last_root, z._complex.dat[0], z._complex.dat[1])        
+            sig_on()
+            for i in range(max_iter):
+                # We recode what would be the following simple Python
+                # algorithm in GSL instead:
+                #    root = root - f(root) / f_prime(root)
+                #    if abs(last_root - root) < tiny:
+                #       break
+                #    else:
+                #       last_root = root
+                root = gsl_complex_sub(root,
+                                gsl_complex_div(gsl_poly_complex_eval(self.c, self.n, root),
+                                    gsl_poly_complex_eval(self.c_d, self.n_d, root)))
+                err = gsl_complex_abs(gsl_complex_sub(last_root, root))
+                if err <= max_err:
+                    break
+                GSL_SET_COMPLEX(&last_root, root.dat[0], root.dat[1])                    
+            sig_off()
+            ans.append((z._new_c(root), i+1, err))
+        return ans
+
+###############################################################
+# Cython code to efficiently find all complex roots of a real
+# polynomial using GSL.  This is *much* faster than using numpy.
+###############################################################
+
+def cdf_roots_of_rdf_poly(f):
+    """
+    Return the CDF roots of a polynomial with coefficients in RDF.
+    Uses a very fast function in GSL that works by computing the
+    eigenvalues of the companion matrix. 
+    
+    INPUT:
+        - f -- polynomial with RDF coefficients
+    OUTPUT:
+        - list -- all CDF roots of f
+
+    EXAMPLES::
+
+        sage: from sage.schemes.elliptic_curves.chow_heegner_fast import cdf_roots_of_rdf_poly
+        sage: f = RDF['x']([1..4])
+        sage: cdf_roots_of_rdf_poly(f)
+        [-0.605829586188, -0.0720852069059 - 0.638326735148*I, -0.0720852069059 + 0.638326735148*I]
+        sage: f.roots(CDF, multiplicities=False)
+        [-0.605829586188, -0.0720852069059 - 0.638326735148*I, -0.0720852069059 + 0.638326735148*I]    
+    """
+    cdef Py_ssize_t i, n = f.degree() + 1
+    cdef double* a = <double*> sage_malloc(sizeof(double)*n)
+    if not a:
+        raise MemoryError
+    cdef double* z = <double*> sage_malloc(sizeof(double)*2*n)
+    if not z:
+        sage_free(a)
+        raise MemoryError
+    
+    cdef list v = f.list()
+    for i in range(n):
+        a[i] = v[i]
+
+    cdef gsl_poly_complex_workspace* w = gsl_poly_complex_workspace_alloc(n)
+    sig_on()
+    gsl_poly_complex_solve(a, n, w, z)
+    sig_off()
+    gsl_poly_complex_workspace_free(w)
+    
+    rts = [CDF(z[2*i],z[2*i+1]) for i in range(n-1)]
+    rts.sort()
+    
+    sage_free(a)
+    sage_free(z)
+    
+    return rts
diff --git a/sage/schemes/elliptic_curves/ell_rational_field.py b/sage/schemes/elliptic_curves/ell_rational_field.py
--- a/sage/schemes/elliptic_curves/ell_rational_field.py
+++ b/sage/schemes/elliptic_curves/ell_rational_field.py
@@ -5130,6 +5130,23 @@
         b = E.a6()
         return mod5family.mod5family(a,b)
 
+    def chow_heegner_point(self, F):
+        """
+        The Chow-Heegner point on the optimal curve E associated to
+        the optimal curve F of the same conductor.
+
+        EXAMPLES::
+
+            sage: P = EllipticCurve('37a').chow_heegner_point(EllipticCurve('37b')); P
+            Chow-Heegner point on 37a1 associated to 37b1
+            sage: P.point_exact()
+            (6 : 14 : 1)
+            sage: P.numerical_approx()
+            (6.00000000000... : 14.0000000000... : 1.00000000000000)        
+        """
+        import chow_heegner
+        return chow_heegner.ChowHeegnerPoint(self, F)
+
     def tate_curve(self, p):
         r"""
         Creates the Tate Curve over the `p`-adics associated to
